# Лекция 14

(Говорящая голова)

Я рад вас снова здесь видеть. В значительной степени, потому что
сегодня мы добрались до заключительного урока модуля. И последней
темой в нём станет достаточно запутанная, но мощная возможность языка
— наследование. Если быть честным, то нужно отметить, что уже любую
программу можно написать с имеющимися у вас знаниями. Но использование
дополнительных инструментов сделает вашу программу более гибкой,
эффективной, и симпатичной. Вот по этой причине наследование нам
придется рассмотреть. Ну и конечно же, потому что это основополагающая
идея объектно-ориентированного программирования.  Весь дальнейший
материал будет активно соприкасаться с предыдущими темами, поэтому
убедитесь что вы хорошо повторили прошлые уроки, после чего
возвращайтесь сюда и мы начинаем

(видео конспект)


https://drive.google.com/open?id=1KxY3HZbOnSLN4HozQ33RmLO35pdnU5CN наследование

----------------------------------------------------------------

(Говорящая голова)

Как вы только что увидели, наследование — это просто обобщающий
термин. Возможно, даже не самый лучший. В том формате, в котором
увидели, слово "заимствование" мне нравится больше. Ну раз в мире
программирования эту штуку принято называть наследованием, мы будем
придерживаться правил. Таким образом, в случае наследования мы
определяем родителя текущего класса. В дальнейшем, используя объекты,
вы обращаетесь к различным свойствам и методам. Есть ли в текущем
классе это свойство или метод не найдено, то, прежде чем выдавать
ошибку, питон попытается найти нужный элемент в родительском классе. И
только если там тоже ничего не найдено — тогда будет создана
ошибка. Иначе, будет возвращет метод либо свойство родительского
класса. Это чем-то похоже на метод Get для словарей, правда нам не
нужно на месте говорить, что мы хотим попытаться найти свойствo, a
если не получится - использовать дефолтное значение. Вместо этого, все
условности мы определяем в момент создания класса, а в будущем просто
наслаждаемся его использованием. Двигаемся дальше

(видео конспект)


https://drive.google.com/open?id=1Zj1lEzFyNt2DICY-G5f7sbnpjMWj8WKe Иерархия наследования

----------------------------------------------------------------

(Говорящая голова)

Наследование оказывается невероятно удобным, когда вы используете уже
существующие библиотеки кода. Если вы находите какой-то превосходный
класс, в котором не хватает нескольких методов - не будете же вы
переписывать оригинальную библиотеку. Вместо этого вы просто создаете
свой собственный класс, наследующей от оригинала, и добавляете
недостающее звено. В дальнейшем просто используйте свой класс,
обладающий всем функционалом библиотечного и ещё небольшим
бонусом. Также, если вдруг библиотечный класс будет обновлён автором и
в нём будут исправлены какие-то баги — благодаря тому что вы не
копируйте код библиотечного класса, а наследуете — все изменения
оригинала автоматически появится и в вашем коде. Так что наследование
еще и помогает в долгосрочных проектах. Но вот что делать если у вас
есть десяток классов и в каждом из них есть что-то интересное что вы
хотели бы добавить свой класс, Не наследоваться же от всех
одновременно? Или, всё-таки можно?

(видео конспект)


https://drive.google.com/open?id=1HTPt5VeZiQMiiNFvV2wb5-VGgVm73Rdo Множественное наследование

----------------------------------------------------------------

(Говорящая голова)

Если вы действительно успели согласиться с тем что всё просто,
вынужден вас разочаровать. Всё-таки небольшая проблемка есть. А если
оба класса от которых мы наследуемся, определяют метод с одинаковым
названием? Какой из них мы будем одалживать в классе наследнике? А
если классов от которых мы наследуемся - 10?  А если они все в свою
очередь, также наследуются от других классов? Поэтому нам нужны
какие-то правила регулирующие порядок заимствования. И, как ни
странно, такие правила существуют.  Вот как это система работает в
реальном коде

(видео конспект)


https://drive.google.com/open?id=1gnRpZrvjJ2LwTmnJoB92z5tCPLFqouSg mro

----------------------------------------------------------------

(Говорящая голова)

Стало немного сложнее, но я был честен в начале занятия и сразу
признался что всё будет запутанным. Правда если хорошая новость — вот
этот вот порядок проверки родительских классов — это самая сложная
часть наследования в питоне. Все остальные детали будут достаточно
очевидными. Да и осталось нам с вами разобрать всего одну тонкость
наследования — способ использовать родительские методы. Мы уже увидели
что все методы по умолчанию наследуются, но если в текущем классе
определенны элементы с таким же именем — происходит замена. А как быть
если я не хочу полностью заменить оригинальный метод, а всего лишь
хочу его немного расширить? Для этого мне нужно как-то умудриться в
своём переписаном методе вызвать оригинальную версию. Есть не
вдаваться в тонкости того как онo работает под капотом, то способ
выполнить эту задачу должен вам понравится.

(видео конспект)


https://drive.google.com/open?id=1CjiLyUDJ9fmaAxjdWEZGLtUBEYFapWwy super

----------------------------------------------------------------

(Говорящая голова)

Кстати, наследоваться можно от любых типов данных включая даже
встроенные. Так что если вдруг у вас возникнет сумасшедшая мысль —
создать улучшенные числа, то вполне можете наследоваться от базового
класса числа, дробного или целого, и нарастить на него необходимый
функционал. В принципе, идея весьма неплохая - почему бы нам не
попробовать это сделать сейчас. Как насчёт того чтобы добавить
несколько удобных методов для каждого из пройденных нами типов
данных. Со временем вы обнаружите, что это достаточно распространённая
практика и в интернете полно библиотек в которых реализовано гораздо
больше чем вы можете себе представить. Ну найти что-то в интернете вы
успеете всегда, а вот писать код вместе со мной у вас получается не
так часто, потому выбор очевиден.

(видео конспект)


https://drive.google.com/open?id=1Pnf3k-Y4VLtrS2ldqQjhbd1ItP_mHuKH Наследование встроенных типов

----------------------------------------------------------------

(Говорящая голова)

И вторая часть нашего урока — обработка ошибок. До сегодняшнего дня у
нас постоянно возникали какие-то ошибки — иногда мы пытались получить
несуществующие индексы списка, иногда несуществующий ключ словаря,
складывали строки с числами, преобразовывали несовместимые типы
данных, сравнивали что-то, что нельзя сравнивать. Нет ничего проще чем
создать ошибку в питоне. И было бы весьма грустно, если бы любая, даже
самая несущественная ошибка, окончательно ломала бы вашу
программу. Разумеется, продолжать работать в случае возникновения
ошибки — не самая лучшая идея. А что если вы знаете о возможности
возникновения этой ошибки и вы понимаете, что это скорее не поломка
программы, а просто необычная ситуация и она не мешает работе вашего
кода? Более того, вы знаете, что нужно сделать, чтобы исправить эту
ошибку. Например, если вы пытаетесь открыть несуществующий файл,
почему бы просто не создать пустой файл, вместо поломки. Не в любой
ситуации такое утверждение логично поэтому стоит быть крайне
внимательным к тому, что является исключительной ситуацией, а что
нет. И тут нужна ваша бдительность, потому что для кода нет никакой
разницы. Учимся фиксить ошибки

(видео конспект)


https://drive.google.com/open?id=1lkPsU26gvM1P7ftIrZDKdG55cwEwBztX try

----------------------------------------------------------------

(Говорящая голова)


Ну если вам нужно обрабатывать только ожидаемые ошибки то писать
except который работает в случае любой проблемы — это несколько
странно. Нам нужно как-то написать except, который актуален для
конкретной ошибки, но не для других. То есть, если в строке вычислений
мы складываем число и строку — подобную ошибку мы должны отловить
исправить. Но если мы делим число на 0 — то к такому судьба нас не
готовила, и мы подобную ошибку отлавливать не должны. Она по-прежнему
должна ломать всю нашу программу, чтобы мы выяснили, как такое
возможно и как это исправить. Таким образом нам нужен более
таргетированный блок отлова ошибок. И давайте называть эти штуки не
ошибками, а исключениями, чтобы подчеркнуть что хоть они необычные, но
ожидаемые ситуации в нашей программе. И вот как можно разделять
отдельные исключения от ошибок

(видео конспект)


https://drive.google.com/open?id=1-FTuZ50V9e-eCiQxUXeKwk84oe7lfLsT except

----------------------------------------------------------------

(Говорящая голова)

Хорошо, теперь мы умеем перехватывать ошибки исправлять их. А если мы
перехватываем одну из нескольких возможных ошибок, и нам хотелось бы
узнать он ней подробную информацию? Например, мы знаем как ее
пофиксить, мы ее фиксим, но нам также хотелось бы залогировать
куда-нибудь информацию о том что ошибка произошла.  Причём, не просто
указать тип ошибки, а сохранить сообщение, которое в другой ситуации
выводилось бы на экран. При сложение числа и строки, не просто
сохранить файл информацию о том что произошла ошибка определенного
типа, а написать что была произведена попытка сложить число и
строку. А еще неплохо было бы научиться создавать свои собственные
ошибки — тогда вы сумеете писать код в более естественный для питона
форме

(видео конспект)


https://drive.google.com/open?id=1pADtIPFCoBEppQDYs1rTKf8QXZZEIxtV raise


----------------------------------------------------------------

(Говорящая голова)

Это всё что вам стоит знать об объектно-ориентированном
программировании для начала своей карьеры в разработчика. Разумеется,
деталей, особенностей и возможности гораздо больше, чем мы успели
разобрать. Но многие тонкости вам не понадобятся либо в первое время,
либо до тех пор пока вы не столкнетесь с какой-либо
узкоспециализированной деятельностью. В принципе, не пытайтесь узнать
всё, главное хорошо разберитесь в основах. Мне всегда казалось что в
питоне объектно ориентированное программирование реализовано
невероятно простым образом для конечного пользователя. Оно может вам
показаться отличным от каких-либо классических описаний с упоминанием
полиморфизма, инкапсуляции и наследования, но лишь потому что в питоне
оно реализована по-своему. Если не цепляться за академическое
определение, то ООП тут простое и удобное в использовании. Вы создаете
объекты, вызываете методы, определяете свойства. При росте проекта вы
описывайте иерархию наследования классов. Зачем всё усложнять? Вот
такой простоте есть, разумеется, и недостатки — особенно если вы
сознательно пытаетесь сломать код. Но до тех пор пока вы следуете
определенным стандартам и соглашениям, подобная простота будет вам
только на руку.

Ну а теперь вас ждут домашние и контрольные работы, после выполнения
которых вас буду ждать я.  Но уже на следующем занятии и в следующем
модуле.  До скорой встречи