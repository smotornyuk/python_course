# Лекция 11

(Говорящая голова)

Давно не виделись. Я крайне рад тому, что вы наконец добрались до
этого модуля. Хоть у вас уже получается писать отличные программы,
которые ещё и делают что-то полезное, но всё пройдено ранее в большей
степени касалась основу написания кода на питоне. Теперь же пришло
время поговорить о том, без чего не обойдется ни одна настоящая
программа. А именно, Правильно организованный код. Возможно , на
последний занятиях вы ощутили, что функций и переменных становится
слишком много — их нужно как-то сгруппировать и отложить в сторону,
потому что найти необходимый фрагмент , временами, оказывается
невозможного сложным. В этом модулем ознакомиться с двумя уровнями
организации, во-первых — классы, которые позволят сгруппировать код по
сфере его применения, и, во-вторых, библиотеки кода, которые позволят
разделить Вашу программу на несколько файлов. Больше часть времени мы
уделим классом — потому что в питоне на них основывается абсолютно
всё. И, к тому же, Они как раз таки и является тем инструментом с
помощью которого Выпишите объектно-ориентированный код.  Наверняка вы
уже слышали такой термин, И даже если нет — звучит он достаточно
солидно.

Ну что ж, насколько сильно мы бы не соскучились друг по другу,
давайте-ка как можно быстрее приступим к новым знаниям

-----

(видео конспект)

https://drive.google.com/open?id=1_8Zj7P-xpSGZyav6ywHPAOlUrXamm7UU
определение классов

-----

(Говорящая голова)

В чём практическая польза от подобной конструкции?  Внутри питона
термин класс — это синоним термина тип данных , а значит, любой класс
— это конструкция, описывающая данные. Вы уже знакомы с типами строк,
чисел, списков , А теперь вы можете даже создавать свои собственные
типы данных. Выгоды в этом достаточно много — можно как и описать
что-то принципиально новое чего еще не существует в питоне , например
тип данных — человек, так и создать слегка модифицированный и
улучшенный тип данных на основании уже существующего — например Почему
бы не создать умную строку , в которых можно будет изменять отдельный
символ, как элементы в списках. Или же создать тип чисел , который
позволяет деление на ноль. И вот как обычно происходит описание нового
типа данных

(видео конспект)

https://drive.google.com/open?id=1XZ5QrtK3dqcRJuozfdi5YOOtxQ4PpkRy
область видимости классов

-----

(Говорящая голова)

Прежде чем мы двинулись дальше, стоит раскрыть одну страшную тайну. До
этого я вот серьёзно обманывал, говоря о том что методы содержатся в
определённых значениях. В действительности, ни одна строка не имеет
методов, все методы принадлежат классу строк. Означение, сами строки,
эти методы временами заимствует. Тоже самое касается и всех остальных
типов данных — в действительности, все методы — это просто функции
внутри класса. И сейчас стоит увидеть пару доказательств этой теории

(видео конспект)

https://drive.google.com/open?id=14PhcoTcP3d6IJPpP4IPoAlKjrMoD_YzG
встроенные классы

-----

(Говорящая голова)

Хорошо, Вы уже должны были поверить в классе и убедиться в том что они
вам даже знакомы. А как теперь создавать объекты этих классов? Со
строками было просто — поставил кавычки, Вот и строка. С числами ещё
легче — нужно просто написать число. Списки и словари работали по
похожей схеме — выставите пару скобок и внутренних определяет
содержимое данной коллекции. Но если у меня есть возможность создать
собственный тип данных то скобки скоро закончатся, так что должен быть
какой-то другой способ создавать объекты.  Если вы были достаточно
внимательный то вы его уже даже знаете. Альтернативная способом
создания объектов, или даже основным, более универсальным, является
вызов класса как функции. Ведь я сегодня уже показал что классы можно
вызывать, правда в этот момент ничего не происходило, а теперь мы
увидим, что происходит достаточно много интересного

(видео конспект)

https://drive.google.com/open?id=1MdQxIURJKkK1rm-DncZ5hx8X7SrfEs_L
создание объектов

-----

(Говорящая голова)

Наверное Вы согласны с тем, что такая форма записи слегка странная — У
меня есть какой-то аргумент, в котором будет либо объект из которого я
вызываю метод, либо ничего если я вызываю метод из класса. Нам
приходится писать в функции, с учетом 2 возможных способов вызова. Это
может показаться достаточно неудобным но только до тех пор пока вы не
попытайтесь вспомнить, Как часто вы вызывали какой-то метод из класса?
До сегодняшнего дня, Вы практически не занимались таким. Таким
образом, вы можете просто игнорировать возможность вызова метода из
класса, и предполагает что методы абсолютно всегда будут вызываться из
какого-то объекта. И указывать в каждом методе обязательный аргумент —
сам объект. Да, это наиболее распространенная практика, и ее мы
несколько раз повторим для лучшего запоминания.

(видео конспект)

https://drive.google.com/open?id=1zckRrSZ1mW6WdbVWBiJ3KyF5jg7cEm1u
методы объектов

-----

(Говорящая голова)

Договоренности — это весьма хорошо. Теперь мы можем не морочить себе
голову разными если. Мы просто уверены в том что наш метод будет
всегда вызываться с нашим объектом в первом аргументе. И выходит что
все методы работают относительно никого объекта жертвой. А если
смотреть на вызов методов, то кажется что сам объект выполняет эти
действия. Если мы хотим узнать имя объекта, то мы хотим узнать
собственное свойство этого объекта , если мы захотим изменить имя, то
мы захотим изменить в собственное имя конкретно этого объекта. То
есть, первый аргумент любого метода — Это не просто объект
соответствующего класса, это сам объект который выполняет действия. С
учётом таких умозаключений, мы можем слегка модифицировать Наш код

(видео конспект)

https://drive.google.com/open?id=1HAqpBNrkN0Mnl1UZyxc5SWKMQK4fPQqS
self

-----

(Говорящая голова)

И Куда уж без практических примеров. Давайте попробуем создать новый
тип данных. Не просто какую-то абстракцию а а реальный полезный
тип. Пусть это будет какая-то точка в двумерном пространстве. Что
может потребоваться от такого типа данных? У него должна быть позиция
— смещение по оси X и по оси Y. У нас должна быть возможность
передвинуть объект в любом из направлений. И, возможно, мы должны быть
способны сравнить две точки. С такими требованиями можно уже
приступать к работе

(видео конспект)

https://drive.google.com/open?id=1mLemb6P-GqSehXDjsD_YgBHfzJmQ30pX
2d point

-----

(Говорящая голова)

И никогда не пытайтесь себя ограничить в момент описание классов — вы
вольны придумать любые методы и возможности поведения ваших
объектов. Да, конечно, если методов будет слишком много, в них очень
легко запутаться. Но если вы будете всё хорошо документировать, то я
не вижу никаких проблем в создании дополнительных методов которые
просто облегчат вам жизнь. Что можно улучшить в нашем классе?
Во-первых, Мне не нравится указывать отдельно параметры X и Y после
создания объекта. Если вдруг я приду на трехмерную систему координат,
мне придётся указывать целых три параметра после создания объекта
. Хотелось бы инициализировать объект стартую данными в более простой
форме. Во-вторых, мои объекты достаточно сложно выводить на
экран. Если вы попытаетесь использовать Print, то вы просто увидите
что это объект никого класса Point. Но вы не увидите каких-либо
бонусных деталей. Каждый раз уточнять в ручную что вас интересует
позиция x и y слишком скучно, Так что здесь есть к чему стремиться.  И
несколько бесполезных фишек тоже не помешает . Давайте попытаемся
сделать мир, или хотя бы наш класс, лучше


(видео конспект)

https://drive.google.com/open?id=1W8o-5kRLo9MF_v62_OSMTz9mV2G2vcez
Улучшения точки

-----

(Говорящая голова)

Только что мы избавились от свойств определенных внутри класса , в
пользу свойств полученных из методы инициализации. Как у меня
получилось изменить свойство которые не были Определены в классе?  Это
стандартное поведение всех созданных вами классов — вы не ограничены в
добавление новых свойств в объекте ваших классов. Кроме того что вы
можете определить некий набор свойств в момент описание классов, на
протяжении всего времени жизни объекта Вы можете добавлять в него
новый свойства. Важно понимать, что эти свойства будут добавлены в
один единственный объект. Если они не прописаны в самом классе, другие
объекты будут выдавать ошибку при попытке извлечения подобных
свойств. Таким образом вы можете сделать отдельные объекты
особыми. Или же, если вы договоритесь добавлять новые свойства,
неопределённые в самом классе, только в методе-инициализаторe , и
будете вызывать этот метод для каждого Нового объекта — то все объекты
будут однородными. Зачем же вам может понадобиться подобная стратегия,
если гораздо проще определить свойства в самом классе и не
заморачиваться методами? А причину вы сейчас увидите

(видео конспект)

https://drive.google.com/open?id=1K1Lmi26TTNnTLsqABz_eR8GZgq9-EcAN
Свойства класса и объекта

-----

(Говорящая голова)

Если мы будем определять свойства только для объектов , то появляется
небольшой шанс того, что некоторые элементы могут
отсутствовать. Например, мы можем попытаться с читать свойство,
которое в этом объекте еще не возникло , что приведет нас к
ошибкe. Разумеется, никто не любит ошибки и нам нужно каким-то образом
их избежать.  Значит нам нужно проверять наличие свойства в объекте
перед его извлечение , хотя бы для отдельных свойств. А ещё лучше,
пойти по стратегии словарей — использовать какую-то функцию,
возвращающую искомое значение или что-то дефолтнoe в случае ошибки.
Раз я об этом уже заговорил, то можно предположить что такие функции
либо существует, либо нам их придётся сейчас написать. Спешу вас
обрадовать, они уже существуют и нам их нужно только рассмотреть.

(видео конспект)

https://drive.google.com/open?id=1FJdAZ8coWslHIA98ukr95ypRjBscecST
работа со свойствами

-----

(Говорящая голова)

Вот на этом и заканчивается первое занятие посвященное
объектно-ориентированному программированию. Тема Это достаточно
обширная и сложна из-за обилия абстракций. Ну это судьба любого
инструмента — Чем более полезным остановится , чем больше в нём
появляется разнообразных возможностей, тем больше приходится
абстрагироваться и усложнять его использование. Преимущества
объектно-ориентированного программирования в его стремлении отразить
происходящие в коде на реальный мир. Вы уже не пытаетесь выразить
решение с помощью абстрактной функции, переменных и циклов. Вы
по-прежнему используете вышеупомянутое но уже для генерации свойств и
методов. Все свойства — это характеристика объекта . Все методы — это
возможности объекта. У человека есть цвет глаз, рост, имя . человек
может пить, есть, спать, и многое другое. Значит у нас есть человек со
свойствами и методами, и мы можем его описать в терминологии
объектно-ориентированного программирования. Тоже самое касается
абсолютно любого предмета, который Вас окружаeт. Что вы больше не
будете пытаться подобрать слова из мира программирования для описания
реальности, вместо этого вы будете просто описывать реальность. Да, на
деле всё немного сложнее, Но вы к этому быстро привыкнете. А я успел
отвыкнуть от таких Долгих бесед и мне нужна небольшая передышка. До
следующей встречи
