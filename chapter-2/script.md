
И снова привет. Если вы все еще тут - значит работа с терминалом вас
не смутила и вы действительно готовы к тому, чтобы начать изучать
python. Тогда, думаю, нам стоит продолжить экспериментировать с
числами - не забывайте, что python был создан математиком, потому
очень многое тут основывается на числах. Но, если я так к ним
прицепился, значит существует и нечто другое, не только числа? Если у
вас появилась подобная идея - вы абсолютно правы. И именно
разнообразие живности в python и попытки его категоризировать и станут
нашей отправной точкой.

Многие люди обожают разбивать все на группы, сортировать,
классифицировать и клеить ярлыки. Программисты - не исключение. И
абсолютно все, с чем вы сталкиваетесь в повседневной it жизни в
большей или меньшей степени поддается группировке. Особенно данные -
ведь вокруг них все всегда и крутится.

Все данные в python разделены на множество групп. Причем, в
зависимости от характеристики, которая вас интересует, количество
групп и принадлежность к ним могут оказаться весьма запутанными. Самой
базовой классификацией можно считать разделением на типы - это
наименее абстрактное и самое необходимое для компьютера распределение.

Если вы имеете представление, с какими данными придется работать - вы
можете заранее отбросить ненужные инструменты, чтобы не засорять
рабочую область. Если вы работаете с числами - вероятнее всего вы
будете выполнять с ними арифметические операции и, в результате,
будете потреблять ресурсы процессора. Но, каким бы большим не было
число, вряд ли оно окажется больше первой части "Гарри Поттера", а
значит вам почти не нужна компьютерная память. А вот если вы работаете
с текстом - вероятно он будет занимать гораздо больше места, но вы не
станете пытаться сложить все буквы в одну - как вообще их
складывать. Скорее вы будете дополнять текст. С меньшей вероятностью
вносить точечные правки в содержимое. То-есть, вы будете
манипулировать множеством слов, но сами слове с наибольшей долей
вероятности, остануться неизменными.

А если это изображения? Мы имеем множество пикселей, которые нужно
отобразить на мониторе. Если мы применяем эффекты - каждый пиксель
нужно последовательно изменить по определенным правилам.

Кодирование видео... тут стоит просто выключить компьютер и пойти на
улицу, встретиться с друзями. Это слишком сложно.

Но что нужно понимать - сам тип данных, которыми мы манипулируем,
имеет критическое значения для определения вероятностных операций и
приоритетных ресурсов для выполнения операции. Потому почти все языки
программирования просто обожают типы данных.

Как же дела обстоят в python? Ответ на этот вопрос зависит от точки
зрения.

Например - все данные в python - это объекты. Что означает что все
данные, кроме того, что сами по себе являются непосредственной
информацией, так же содержат в себе метаданные - набор свойств и
характеристик, которые описывают данные, но не являются ими. Например
текст. Существует сам текст, как информация. А существует размер
текста, кодировка, язык - как метаданные. Так вот - все, чем вы
управляете в python - имеет свойства. Кроме того, все объекты - это
высокоуровневые абстракции. Они стремятся быть похожими на ваше
окружение, чтобы их было проще понять. Потому у объектов есть методы -
те действия, которые они могут выполнять. Например, наш злополучный
текст. Он может изменить регистр. Это действие. Он может ответить на
вопрос, содержится ли в нем некая фраза. Или заменить в себе одно
слово на другое. На самом деле, разумеется, текст, как создание
неразумное, все это делать не умеет. Любой процесс выполняется самим
интерпретатором. Но внешне все построено таким образом, что нам
кажется будто взаимодействует с нами именно текст. Благодаря этому не
приходится держать в уме факт существования посредника интерпретатори
и можно просто поговорить по душам с буквами.

Абстракции - это чудо. Нередко слишком уж расчудесное и непонятное, но
в большинстве случаев - крайне удобное. Пользуясь абстракциями, вы
можете не вникать слишком уж дотошно во внутренние процессы, а просто
пользоваться инструментом. Вот я, к слову, крайне слабо представляю,
как мое безумное шлепанье пальцами по клавиатуре приводит к появлению
букв на экране, но это ни разу не мешает мне получать деньги за
написание кода. Но все же старайтесь всегда, как подвернется
возможность, закопаться чуть больше в происходящее и раскрыть
настоящую реальность скрытую за абстракцией. Это поможет не только
вашему профессиональному росту, но и просто научит смотреть на мир
более творчески.

Вернемся к типам. С первой новостью разобрались, давайте посмотрим,
что еще можно о них сказать. В противовес абстракциям можно выделить
конкретные типы. Например, уже упоминавшиеся числа и текст. в python
существует разделение чисел на целые и дробные. В случае
арифметических операций, разницу заметить очень сложно. Но вот вне
арифметики это абсолютно разные значения. Как например, вы можете
съесть полторы пиццы. Но вот когда в лифте едет полтора человека - это
не может не вызывать подозрений. Так что дроби и целые числа -
достаточно разные типы данных.

Текст в python - это просто коллекция букв, упорядоченных определенным
образом. Каков размер коллекции, на каком языке она написана - не
имеет абсолютно никакого значения. То-есть, напишите вы одну букву,
одно слово, предложение или огромную книгу - для python это лишь
текст.

Затем - булевы значения. Эти страшные вещи очень хороши для построения
логических цепочек, в чем, собственно, и заключается их
задача. Хорошей особенностью булевых значений можно считать их
конечность. Таких значение всего два - правда и ложь. Название не
особо принципиально, просто эти два слова наиболее распространены и
используются в python. Но вы можете ссылаться на них любыми двумя
антонимами, один из которых можно интерпретировать как "да", а
второй - "нет". Может быть 1 и 0? Или "включено" - "выключено"? Или
"лево" - "право"? В зависимости от конкретики ситуации - может подойти
любое определение. Так что решение python привязаться к правда-ложь -
только дань традиции.

Кроме этого, есть еще один тип данных, который еще более
лаконичен. Специальное значение, которое означает "ничего". Под него
даже выделили отдельный тип - неплохо же?

Дальше будет сложнее. Существуют еще массивы, списки, множества,
кортежи, словани, хеши и бесчисленное множество типов данных из
дополнительных библиотек. Не поверите, но вы даже можете создавать
свои собственные типы данных. И мы непременно этим займемся в будущем.

Давайте отбросим эту жесткую конкретику и вернемся к теплой ламповой
абстракции. Я вот люблю группировать типы в противоположные коалиции.

Сначала, по изменяемости. Существуют типы данных, которые совершенно
неизменяемы. В python этот аспект контролируется на уровне доступа к
памяти. Выделив память под неизменяемый объект, вы уже не сможете
переписать отдельный сектор этой памяти. Вместо этого вам нужно
затребовать новый участок памяти, или же полностью освободить прежде
занятое пространство. И туда уже вы сможете записать новые
данные. То-есть, данные не будут неуязвимыми - просто вы не можете
изменять отдельные их части. К этой группе можно отнести числа и
строки.

Напротив стоят изменяемые данные. В данном случае, единожды выделив
память под объект, вы можете менять фрагменты этой памяти, переделывая
объект по кусочкам, как конструктор. К подобной группе относится
большая часть существующих и ваших будущих типов данных.

Затем посмотрим на сложность значений. Существуют атомарные
значения. Они неделимы. Число - невозможно разделить на отдельные
фрагменты. Кто-то может поспорить, указав на то, что у чисел есть
разряды - десятки, сотни и тысячи. Но в случае python такая градация
отсутствует. Аналогично ведут себя булевы значения. И любой другой
тип, призванный представлять нечто монолитное в этом мире. В то время
как строки - это коллекция отдельных элементов - символов. А вот
символ - уже неделимое. Но для python строка текста и отдельная
буква - равнозначны. Выходит, текст - это нечто двойственное.

Схожей градацией будет разделение на примитивы и комплексные
значения. Примитивы представлены в виде одного фрагмента
информации. Те же числа, текст, возможно, изображение. А вот тип
данных, способный представить точку в трехмерной системе координат -
комплексное значение, потому что он состоит из x, y и z составляющих.

В конце концов - упорядоченные и неупорядоченные коллекции. И опять
текст. Он упорядочен. Если мы переставим буквы местами - мы получим
абсолютно другой текст. А вот если у нас есть пакет с конфетами(кто
сказал, что конфеты и пакеты не могут быть типами данных) - мы может
его сколь-угодно долго перемешивать - это по-прежнему пакет с теми же
конфетами. Если, разумеется, мы не обладаем чрезмерной ловкостью рук и
наглостью.

Пожалуй, на этом стоит остановиться в классификации данных. Как
видите, понимание типов позволяет вам заглянуть за ширму
абстракции. Очень часто принадлежность к конкретной группе
подразумевает наличие некоторых возможностей. Потому со временем вы
сможете просто угадывать и чувствовать правильный код, даже не
заглядывая в документацию. Вы верите, что вода мокрая, а зимой -
твердая. Вы не станете прыгать из самолета, без парашюта. Кстати, я
прыгал с парашютом - в какой-то момент вы будете уверены, что и с ним
вы не станете прыгать, потому что земля низко и твердая. То же самое и
с типами данных - вам не нужно будет что-то проверять, вы просто
будете это знать, основываясь на опыте.


---


Но это еще не все. Кроме того, что данные делятся на множество разных
групп, сами языки программирования сами по себе делятся на разные
группы в зависимости от отношения к данным.

Во-первых, явность типизации. В некоторых языках вам необходимо
указывать тип данных, которые вы собираетесь записать в переменную,
явным образом. Как мы видели ранее - в python подобное не
практикуется. Мы просто присваиваем значение в переменную и python сам
догадывается, что это число.  Соответственно, тут используется неявная
типизация.

Затем, динамичность типизации. Создавая переменные, мы свободно могли
переписывать их значения, правда мы пока лишь переписывали числа
другими числами. Во многих языках переменная сохраняет тип своего
значения и вы не можете в будущем присвоить текст туда, где раньше
было число. Модель управления переменными в python такова, что в
подобном ограничении нет смысла и вы свободно можете перезаписать
число текстом. Хотя, я сам считаю такую практику крайне
отвратительной, потому что со временем вы просто запутаетесь, пытаясь
определить, а что же там, в этой переменной в данный момент
времени. Так что, если вам придется работать со мной в одной команде -
не увлекайтесь сильно изменениями типов. Вывод: в python используется
динамическая типизация.

И, наконец, строгость типизации. Представьте, что у вас есть текст,
состоящий из трех единичек. Может быть это необычное имя главного
героя в какой-нибудь постапокалиптической истории. Именно потому мы
решили, что этот тип данных - текст. И в наличии так же возраст этого
героя - 48. А теперь мы начинаем складывать имя и возраст героя. Если
вы считаете, что в сумме должно выйти 159 - вы по-своему правы. Но во
мне просыпается чувство праведного гнева - почему мы складываем с
возрастом именно дословную числовую конверсию имени, а не количество
символов в нем - три. Или, если это имя герой получил, когда в
одиночку расправился с одиннадцатью радиоактивными псами. Тогда 1 +
11 + 48 даст нам 60. В общем, нельзя делать поспешные выводы. Этим
отличаются языки со строгой типизацией - значения разных типов,
зачастую, взаимодействовать не могут, если правила взаимодействия не
прописаны явно. Допустим, если бы мы сказали, что хотим посимвольно
перевести имя в число - вышло бы 159. Если бы сказали, что хотим
воспринимать возраст, как имя второго героя - получили бы что то вроде
"11148" - как по мне, попытка сложить два слова должна результировать
новым словом. Именно такая ситуация в python.

А теперь итог. Python - язык с неявной строгой динамической
типизацией. Это можно просто запомнить и хвастаться умными словами
перед друзьями.

---


Теперь сфокусируемся на главной теме этого урока - числах. Проще всего
числа создавать с помощью литералов - специальных форм записи,
результатом которых будет желанная сущность. Звучит стремно, но на
деле оказывается, что литерал числа - это само число. Хотите 1 -
напишите 1. Желаете сотню - напишите 100. Но некоторые правила и
послабления все-же существуют, так что давайте посмотрим живой пример.
