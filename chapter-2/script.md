
И снова привет. Если вы все еще тут - значит работа с терминалом вас
не смутила и вы действительно готовы к тому, чтобы начать изучать
python. Тогда, думаю, нам стоит продолжить экспериментировать с
числами - не забывайте, что python был создан математиком, потому
очень многое тут основывается на числах. Но, если я так к ним
прицепился, значит существует и нечто другое, не только числа? Если у
вас появилась подобная идея - вы абсолютно правы. И именно
разнообразие живности в python и попытки его категоризировать и станут
нашей отправной точкой.

Многие люди обожают разбивать все на группы, сортировать,
классифицировать и клеить ярлыки. Программисты - не исключение. И
абсолютно все, с чем вы сталкиваетесь в повседневной it жизни в
большей или меньшей степени поддается группировке. Особенно данные -
ведь вокруг них все всегда и крутится.

Все данные в python разделены на множество групп. Причем, в
зависимости от характеристики, которая вас интересует, количество
групп и принадлежность к ним могут оказаться весьма запутанными. Самой
базовой классификацией можно считать разделением на типы - это
наименее абстрактное и самое необходимое для компьютера распределение.

Если вы имеете представление, с какими данными придется работать - вы
можете заранее отбросить ненужные инструменты, чтобы не засорять
рабочую область. Если вы работаете с числами - вероятнее всего вы
будете выполнять с ними арифметические операции и, в результате,
будете потреблять ресурсы процессора. Но, каким бы большим не было
число, вряд ли оно окажется больше первой части "Гарри Поттера", а
значит вам почти не нужна компьютерная память. А вот если вы работаете
с текстом - вероятно он будет занимать гораздо больше места, но вы не
станете пытаться сложить все буквы в одну - как вообще их
складывать. Скорее вы будете дополнять текст. С меньшей вероятностью
вносить точечные правки в содержимое. То-есть, вы будете
манипулировать множеством слов, но сами слове с наибольшей долей
вероятности, остануться неизменными.

А если это изображения? Мы имеем множество пикселей, которые нужно
отобразить на мониторе. Если мы применяем эффекты - каждый пиксель
нужно последовательно изменить по определенным правилам.

Кодирование видео... тут стоит просто выключить компьютер и пойти на
улицу, встретиться с друзями. Это слишком сложно.

Но что нужно понимать - сам тип данных, которыми мы манипулируем,
имеет критическое значения для определения вероятностных операций и
приоритетных ресурсов для выполнения операции. Потому почти все языки
программирования просто обожают типы данных.

Как же дела обстоят в python? Ответ на этот вопрос зависит от точки
зрения.

Например - все данные в python - это объекты. Что означает что все
данные, кроме того, что сами по себе являются непосредственной
информацией, так же содержат в себе метаданные - набор свойств и
характеристик, которые описывают данные, но не являются ими. Например
текст. Существует сам текст, как информация. А существует размер
текста, кодировка, язык - как метаданные. Так вот - все, чем вы
управляете в python - имеет свойства. Кроме того, все объекты - это
высокоуровневые абстракции. Они стремятся быть похожими на ваше
окружение, чтобы их было проще понять. Потому у объектов есть методы -
те действия, которые они могут выполнять. Например, наш злополучный
текст. Он может изменить регистр. Это действие. Он может ответить на
вопрос, содержится ли в нем некая фраза. Или заменить в себе одно
слово на другое. На самом деле, разумеется, текст, как создание
неразумное, все это делать не умеет. Любой процесс выполняется самим
интерпретатором. Но внешне все построено таким образом, что нам
кажется будто взаимодействует с нами именно текст. Благодаря этому не
приходится держать в уме факт существования посредника интерпретатори
и можно просто поговорить по душам с буквами.

Абстракции - это чудо. Нередко слишком уж расчудесное и непонятное, но
в большинстве случаев - крайне удобное. Пользуясь абстракциями, вы
можете не вникать слишком уж дотошно во внутренние процессы, а просто
пользоваться инструментом. Вот я, к слову, крайне слабо представляю,
как мое безумное шлепанье пальцами по клавиатуре приводит к появлению
букв на экране, но это ни разу не мешает мне получать деньги за
написание кода. Но все же старайтесь всегда, как подвернется
возможность, закопаться чуть больше в происходящее и раскрыть
настоящую реальность скрытую за абстракцией. Это поможет не только
вашему профессиональному росту, но и просто научит смотреть на мир
более творчески.

Вернемся к типам. С первой новостью разобрались, давайте посмотрим,
что еще можно о них сказать. В противовес абстракциям можно выделить
конкретные типы. Например, уже упоминавшиеся числа и текст. в python
существует разделение чисел на целые и дробные. В случае
арифметических операций, разницу заметить очень сложно. Но вот вне
арифметики это абсолютно разные значения. Как например, вы можете
съесть полторы пиццы. Но вот когда в лифте едет полтора человека - это
не может не вызывать подозрений. Так что дроби и целые числа -
достаточно разные типы данных.

Текст в python - это просто коллекция букв, упорядоченных определенным
образом. Каков размер коллекции, на каком языке она написана - не
имеет абсолютно никакого значения. То-есть, напишите вы одну букву,
одно слово, предложение или огромную книгу - для python это лишь
текст.

Затем - булевы значения. Эти страшные вещи очень хороши для построения
логических цепочек, в чем, собственно, и заключается их
задача. Хорошей особенностью булевых значений можно считать их
конечность. Таких значение всего два - правда и ложь. Название не
особо принципиально, просто эти два слова наиболее распространены и
используются в python. Но вы можете ссылаться на них любыми двумя
антонимами, один из которых можно интерпретировать как "да", а
второй - "нет". Может быть 1 и 0? Или "включено" - "выключено"? Или
"лево" - "право"? В зависимости от конкретики ситуации - может подойти
любое определение. Так что решение python привязаться к правда-ложь -
только дань традиции.

Кроме этого, есть еще один тип данных, который еще более
лаконичен. Специальное значение, которое означает "ничего". Под него
даже выделили отдельный тип - неплохо же?

Дальше будет сложнее. Существуют еще массивы, списки, множества,
кортежи, словани, хеши и бесчисленное множество типов данных из
дополнительных библиотек. Не поверите, но вы даже можете создавать
свои собственные типы данных. И мы непременно этим займемся в будущем.

Давайте отбросим эту жесткую конкретику и вернемся к теплой ламповой
абстракции. Я вот люблю группировать типы в противоположные коалиции.

Сначала, по изменяемости. Существуют типы данных, которые совершенно
неизменяемы. В python этот аспект контролируется на уровне доступа к
памяти. Выделив память под неизменяемый объект, вы уже не сможете
переписать отдельный сектор этой памяти. Вместо этого вам нужно
затребовать новый участок памяти, или же полностью освободить прежде
занятое пространство. И туда уже вы сможете записать новые
данные. То-есть, данные не будут неуязвимыми - просто вы не можете
изменять отдельные их части. К этой группе можно отнести числа и
строки.

Напротив стоят изменяемые данные. В данном случае, единожды выделив
память под объект, вы можете менять фрагменты этой памяти, переделывая
объект по кусочкам, как конструктор. К подобной группе относится
большая часть существующих и ваших будущих типов данных.

Затем посмотрим на сложность значений. Существуют атомарные
значения. Они неделимы. Число - невозможно разделить на отдельные
фрагменты. Кто-то может поспорить, указав на то, что у чисел есть
разряды - десятки, сотни и тысячи. Но в случае python такая градация
отсутствует. Аналогично ведут себя булевы значения. И любой другой
тип, призванный представлять нечто монолитное в этом мире. В то время
как строки - это коллекция отдельных элементов - символов. А вот
символ - уже неделимое. Но для python строка текста и отдельная
буква - равнозначны. Выходит, текст - это нечто двойственное.

Схожей градацией будет разделение на примитивы и комплексные
значения. Примитивы представлены в виде одного фрагмента
информации. Те же числа, текст, возможно, изображение. А вот тип
данных, способный представить точку в трехмерной системе координат -
комплексное значение, потому что он состоит из x, y и z составляющих.

В конце концов - упорядоченные и неупорядоченные коллекции. И опять
текст. Он упорядочен. Если мы переставим буквы местами - мы получим
абсолютно другой текст. А вот если у нас есть пакет с конфетами(кто
сказал, что конфеты и пакеты не могут быть типами данных) - мы может
его сколь-угодно долго перемешивать - это по-прежнему пакет с теми же
конфетами. Если, разумеется, мы не обладаем чрезмерной ловкостью рук и
наглостью.

Пожалуй, на этом стоит остановиться в классификации данных. Как
видите, понимание типов позволяет вам заглянуть за ширму
абстракции. Очень часто принадлежность к конкретной группе
подразумевает наличие некоторых возможностей. Потому со временем вы
сможете просто угадывать и чувствовать правильный код, даже не
заглядывая в документацию. Вы верите, что вода мокрая, а зимой -
твердая. Вы не станете прыгать из самолета, без парашюта. Кстати, я
прыгал с парашютом - в какой-то момент вы будете уверены, что и с ним
вы не станете прыгать, потому что земля низко и твердая. То же самое и
с типами данных - вам не нужно будет что-то проверять, вы просто
будете это знать, основываясь на опыте.


---


Но это еще не все. Кроме того, что данные делятся на множество разных
групп, сами языки программирования сами по себе делятся на разные
группы в зависимости от отношения к данным.

Во-первых, явность типизации. В некоторых языках вам необходимо
указывать тип данных, которые вы собираетесь записать в переменную,
явным образом. Как мы видели ранее - в python подобное не
практикуется. Мы просто присваиваем значение в переменную и python сам
догадывается, что это число.  Соответственно, тут используется неявная
типизация.

Затем, динамичность типизации. Создавая переменные, мы свободно могли
переписывать их значения, правда мы пока лишь переписывали числа
другими числами. Во многих языках переменная сохраняет тип своего
значения и вы не можете в будущем присвоить текст туда, где раньше
было число. Модель управления переменными в python такова, что в
подобном ограничении нет смысла и вы свободно можете перезаписать
число текстом. Хотя, я сам считаю такую практику крайне
отвратительной, потому что со временем вы просто запутаетесь, пытаясь
определить, а что же там, в этой переменной в данный момент
времени. Так что, если вам придется работать со мной в одной команде -
не увлекайтесь сильно изменениями типов. Вывод: в python используется
динамическая типизация.

И, наконец, строгость типизации. Представьте, что у вас есть текст,
состоящий из трех единичек. Может быть это необычное имя главного
героя в какой-нибудь постапокалиптической истории. Именно потому мы
решили, что этот тип данных - текст. И в наличии так же возраст этого
героя - 48. А теперь мы начинаем складывать имя и возраст героя. Если
вы считаете, что в сумме должно выйти 159 - вы по-своему правы. Но во
мне просыпается чувство праведного гнева - почему мы складываем с
возрастом именно дословную числовую конверсию имени, а не количество
символов в нем - три. Или, если это имя герой получил, когда в
одиночку расправился с одиннадцатью радиоактивными псами. Тогда 1 +
11 + 48 даст нам 60. В общем, нельзя делать поспешные выводы. Этим
отличаются языки со строгой типизацией - значения разных типов,
зачастую, взаимодействовать не могут, если правила взаимодействия не
прописаны явно. Допустим, если бы мы сказали, что хотим посимвольно
перевести имя в число - вышло бы 159. Если бы сказали, что хотим
воспринимать возраст, как имя второго героя - получили бы что то вроде
"11148" - как по мне, попытка сложить два слова должна результировать
новым словом. Именно такая ситуация в python.

А теперь итог. Python - язык с неявной строгой динамической
типизацией. Это можно просто запомнить и хвастаться умными словами
перед друзьями.

---


Теперь сфокусируемся на главной теме этого урока - числах. Проще всего
их создавать с помощью литералов - специальных форм записи,
результатом которых будет желанная сущность. Звучит стремно, но на
деле оказывается, что литерал числа - это само число. Хотите 1 -
напишите 1. Желаете сотню - напишите 100. Но некоторые правила и
послабления все-же существуют, так что давайте посмотрим живой пример.

---

> 9 .mkv

Сначала целые числа. Никаких особых методик тут использовать не
нужно. Просто вводите разные цифры и нажимайте enter. Начинать ввод
нужно с начала строки, никаких дополнительных пробелов. Иначе
результатом станет ошибка.

возможно вам покажется сложным читать большие числа в подобной
ситуации. Попытка расставить пробелы между разрядами вызовет ошибку,
ровно как и разделение разрядов точками. Запятые результируют в
необычный формат, так что их тоже использовать нельзя...

В конце-концов, разделение дефисами будет воспринято интерпретатором,
как вычитание и мы снова не получим желаемый результат. Раньше у этой
проблемы решения не было, но начиная с python версии 3.6 у нас
появилась возможность все исправить. Теперь в числах, между любыми
двумя цифрами, можно вставлять нижние подчеркивания. Например -
так... Или так... Или даже вот так... Но нижние подчеркивания
обязательно должны быть одиночными, иначе - ошибка. В принципе, одного
символа должно быть более, чем достаточно для удобного чтения, так что
это ограничение вполне оправдано.

А как насчет отрицательных чисел? Все крайне прозрачно - напишите знак
минуса, после чего - число. Минус должен быть первым символом в
строке, но после него допустимо ставить пробелы. Правда, я в этом
смысла не вижу - если это показатель отрицательности, то будет весьма
логичным прижать этот показатель к тому число, которое он
модифицирует. Между минусом и числом ставить нижние подчеркивания
нельзя, но в самом числе правила остаются прежними, так что вы вполне
можете написать подобное...

Кстати, числа без знака считаются положительными. Но об этом можно
сказать и явно, поставив знак плюс перед числом. Такое может
пригодится разве что для однородности вывода, на практике подобное
использование плюса почти не встречается.

А вот дальше немного плохих примеров. Само по себе, число
воспринимается в python как есть. При добавлении знака слева, число
модифицируется. Если это плюс - ничего не происходит, если минут -
знак меняется на противоположный. Давайте сохраним число в
переменную. Тепер поставим знак перед ней - замечаете, как меняется
результат после добавления знаков перед переменной?

Теперь сохраняем модифицированную переменную. Выходит, второе
значение - прям как первое, но с противоположным знаком. И добавление
префиксов перед ним приводит к противоположному результату. Но, если
присмотреться, то можно заметить, что минус перед второй переменной -
это минус перез значением, которое само по себе обладает каким-то
знаком. Таким образом, мы расшифровываем наш ввод в следующую
конструкцию... И никакой ошибки! Это выражение рассчитывается справа
налево - берем значение, модифицируем, снова модифицируем и только
после этого запоминаем результат.

Значит и следующая запись верна... А также подобный
вариант... Попробуйте добавить на один минус больше и получите число с
обратным знаком. Это же до неприличия логично. У нас есть
положительное число. Умножаем на минус один - оно становится
отрицательным. Еще раз - положительным. Еще раз - снова
отрицательным. И так до бесконечности. Возможно, при добавлении скобок
вокруг значения все станет слегка понятнее?.. Немного забегая вперед,
стоит сказать, что любое значение в python можно завернуть в круглые
скобки, чтобы подчеркнуть порядок выполнения операции. В нашем случае
это ни на что не влияет, но временами скобки позволяют насильно
изменить стандартное поведение интерпретатора.

Пусть подобная запись и выглядит диковатой, но она не нарушает правила
синтаксиса - перед любым значением типа данных, поддерживающего знаки
плюс и минус, можно ставить эти знаки. Добавляя один минус, мы создаем
новое число отрицательное. Но это все еще число, значит оно
поддерживает знаки. Все дальнейшие модификации, до тех пор пока их
результатом будет число, так же позволяют продолжить цепочку. Такую
запись сложно назвать полезной и уж тем более - прозрачной, так что я
бы посоветовал ее избегать.

---

Краткий пересказ увиденного. Код в python нужно писать в самом начале
строки. Числа записываются непрерывным набором цифр, между которыми
допустимо ставить одиночные нижние подчеркивания для повышения
читаемости. так же перед числами можно ставить знак-показатель
отрицательности.

Теперь усложняем. Добавим новый термин - оператор. В случае python,
операторами мы будем называть символы, которые сами по себе не
являются значениями, не имеют типа и не могут быть сохранены в
переменную, но каким-либо образом влияют на свое окружение. Понятие
достаточно размытое, особенно если учесть, что один и тот же символ
может временами быть оператором, а временами - нет. Но пока придется с
этим смирится. Мы уже столкнулись с операторами плюс и минус. В случае
размещения перед числом, они определяют его знак. Само число, точнее
то, к чему оператор применяется, принято называть операндом или
аргументом. Я буду стараться использовать слово операнд, потому что
аргументы мы уже использовали в командной строке. Да и есть еще
несколько ситуаций, для которых я предпочту зарезервировать этот
термин.

Для любителей аналогий, можете воспринимать операторы, как
инструменты, а операнды - как материал. Молоток - оператор, гвоздь -
операнд. Тарелка - оператор, борщ - операнд. Хотя тарелка с борщом
больше похожи на переменную со значением. Что ж, идеальных аналогий не
существует.

Кроме того, мы использовали еще один оператор - пару круглых
скобок. Это группирующий оператор. Им являются обе скобки
одновременно. Невозможно написать только открывающую скобку или только
закрывающую - вы получите ошибку. То-есть, иногда операторы могут
состоять более, чем из одного символа. Кроме того, в отличии от
плюс-минус, скобки применяются не к следующему за ним значению, а к
своему содержимому. Они заставляют python вычислить это содержимое,
прежде чем оно будет использовано далее. Немного позже в этом уроке мы
увидим полезный пример с использованием скобок.

---

> 10.mkv

Вернемся к примерам. Кроме стандартных чисел, в python возможен ввод
значений в двоичной, восьмеричной и шестнадцатеричной
системе. Синтаксис прост.

Ноль - буква b в нижнем или верхнем регистре, затем само число -
двоичная система. Тем, кто с ней не знаком, стоит знать, что в ней
поддерживаются только цифры 0 и 1. Использование других вариантов
вызовет ошибку. После ввода мы увидим результат в привычной там
десятеричной системе - конвертацию python производит автоматически. В
этой записи каждый символ является частью литерала, не оператором,
потому - никаких пробелов! Кроме того, ноль-b - это префикс, который
нельзя разделять нижним подчеркиванием, в то время как после него
правила разделителей остаются стандартными.

Восьмеричная система предполагает те же самые правила, но вместо b тут
используется буква o. Кроме того, допустимый диапазон символов - от 0
до 7 включительно...

И, наконец, шестнадцатеричная система. в виде префикса используем
букву X. для представления чисел 10, 11, 12, 13, 14 и 15 используются,
соответственно, буквы A, B, C, D, E, F, в любом регистре, можно даже
смешивать...

---

Конвертация происходит в автоматическом режиме, благодаря чему вы
можете выполнять с этими значениями любые числовые операции и даже
смешивать разные формы записи в одном выражении. В большинстве случаев
эти форматы нужны только для удобства, если ваш проект удобнее
представлять нестандартными системами счисления. Например, работа с
палитрой цветов в CSS.

---

> 11.mkv

А теперь о дробных числах. Вы же еще помните о том, что в python целые
и дробные числа - это разные типы данных? С точки зрения записи
литералов - они практически такие же, как и целые. Основное отличие -
наличие точки, как показателя дробной части. Вот у нас целое число. А
теперь добавляем точку и дробную часть - теперь это дробь. Стоит сразу
заметить, что точка в этом случае - часть литерала, а не оператор,
потому пробелы вокруг нее не допустимы. Так же с точкой не должны
соседствовать нижние подчеркивания. Внутри же целой и дробной части -
все правила расстановки нижних подчеркиваний остаются прежними.

Для создания дроби сама величина дробной части не имеет
значения. Важно само ее наличие. Наприме один - это целое число. А вот
одна целая и ноль десятых - это дробь. Ноль целое. Ноль целых, ноль
десятых - тоже дробь. Для граничных случаев существует специальная
форма записи. Дробь, в которой дробная часть равна нуля, можно
записать в виде числа с завершающей точкой. Вот такая форма
равносильна добавлению нулевой дробной части. Вот еще пара примеров -
тут видно, что интерпретатор всегда добавляет ноль десятых после
точки...

Таким же образом вы можете опустить целую часть перед точкой и
написать только дробную. Тогда интерпретатор предполагает ноль слева
от точки...

Но не увлекайтесь. Нельзя написать одну только точку - тут уже все
закончится ошибкой.

Перед дробными числами вполне можно ставить показатели знака, но вот
записать их вне десятичной системы нельзя.

И последний вариант - экпоненциальная запись, или научная. Числа вот
такого формата тоже считаются дробными. Вы записываете(без пробелов)
некое число, возможно и дробное, после чего добавляете символ "е" в
верхнем или нижнем регистре. Затем добавляете еще одно число с
необязательным показателем знака. Преобразование выполняется следующим
образом:

- число справа от "е" - это степень, в нее мы возводим десять. Если
  число 3 - получаем тысячу. Если 6 - миллион. 0 - единица.

- умножаем на полученное число ту часть, которая расположена слева от
  символа "е"

Готово. Важно заметить, что любое число в такой форме будет считаться
дробным, даже следующие примеры...

И не забывайте о математике. Если вы пожелаете записать значение
меньше единицы - просто используйте знак минус перед показателем
степени. Несколько примеров...

---

А теперь начинается что-то интересное. Не думаю, что вы записались на
этот курс, чтобы интерпретатор в результате выводил вам в ответ
какие-то циферки. Пора повышать его кпд. Как насчет того, чтобы
добавить еще несколько операторов и сделать из нашей консоли
калькулятор?

Мы уже обсудили, что такое операторы и операнды. А теперь добавим
новый формат классификации. Среди всего прочего, операторы бывают
унарными и бинарными. Унарные операторы мы встречали - они
предполагают наличие одного операнда и работают только с ним. Бинарные
оператор ожидают наличие двух операндов. Первое , что приходит в
голову - сложение. У нас есть оператор сложения, но для работы ему
нужны два значения - те самые слагаемые, от перестановки которых сумма
не меняется. А вот неловкость вся заключается в том, что бинарный
оператор сложения выглядит прям как унарный показатель знака - плюс.

---

> 12.mkv

сравним две записи... Первый случай предполагает простое положительное
число. А вот второй - сложение. В зависимости от окружения, python
выбирает наиболее подходящую форму оператора. Ну, чтобы совсем все
запутать, давайте используем обе формы плюса в одном
выражении.. Заметьте, плюс, который стоит непосредственно перед числом
можно истолковать только как показатель знака. В то время как средний
плюс лучше всего подойдет на роль сложения - любая другая
интерпретация была бы не очень адекватной.

Что стоит знать обо всех бинарных операторах? Стилистически они обычно
выделяются пробелами. И вот эта равноудаленность от двух операндов как
бы намекает, что они оба являются равносильными участниками
операции. Для унарных операторов предпочтительна запись без пробелов,
чтобы показать связь с модифицируемым значением. Но это только
стилистика - вы можете свободно нарушать эти правила. Разумеется, за
все нужно платить. Цена индивидуальности - тихая ненависть ваших
коллег - никто не любит творческое форматирование. Так что в будущем я
буду пытаться писать в общепринятом стиле и периодически делать сноски
о стандартах. Пока же запоминайте, что вокруг любых операторов
допустимо ставить любое количество пробелов, ровно как и не ставить
прообелы вообще.

Оператор сложения не таит в себе никаких сюрпризов до тех пор, пока вы
складываете только числа. Хотя, есть один секрет, но о нем позже. Мы
можем складывать целые числа друг с другом, можем складывать
дробные. И даже можно смешивать. Зачастую python не позволил бы
такого, что два типа чисел настолько похожи, что интерпретатор идет
нам навстречу. Если вы пытаетесь использовать целое и дробное числа в
одной операции - python неявно заменяет целое на точно такую же дробь
с нулевой дробной частью. В итоге оно работает примерно так... И
итогом смешанной операции всегда будет дробь.

Вы вполне вольны использовать показатели знаков и складывать
отрицательные числа... И использование нижних подчеркиваний в
операндах никак не изменит логику. Плюс, как упоминалось ранее, все
нестандартные формы записи чисел будут на лету преобразованы в
десятичную форму...

Ну и вишенкой на торте можно считать возможность использовать
несколько фрагментов в одной строке. Вы можете складывать три, четыре,
сколько-угодно чисел одновременно. Напрмер так... или так.... Только
учтите, что это не отдельный оператор или нестандартная форма -
интерпретатор вычисляет выражение на ходу упрощая его и приводя к
одиночному окончательному значению. Прям как с унарными минусами. В
том случае выражение пошагово поглощало минус за минусом справа
налево. Тут же мы начинаем вычислять сначала результат самого левого
оператора. Полученную сумму мы используем для второго оператора. Потом
так же переходим к третьему. Любое сложное выражение будет в
конце-концов развернуто в одно значение. Так же тут начинают
проявляться два новых понятий, которые будут иметь критическое
значение в будущем. Во превых - приоритет. Если мы складваем
отрицательное число с положительным, то сначала применяется
модификатор знака и только потом сумма. Думаю, если бы мы сначала
сложили две цифры и только потом поменяли их знак - вы бы немного
удивились. Приоритет важен в сложных операциях. Он определяет порядок,
в котором будут выполняться действия. И практически всегда мы можем
контролировать приоритет с помощью круглых скобок. Сравните вариант
без скобок - сложение отрицательного и положительного..., - со
скобочным вариантом - сначала складываем, а потом меняем знак...

Во-вторых, направленность. Хоть это и не повлияло на результат, но
модификатор знака применяется справа налево. Сначала самый ближний к
числу, потом следующий за ним и так далее. В то время как сложение
вычисляет группы слева направо. При наличии нескольких групп с
одинаковым приоритетом, направленность определяет вектор вычислений -
налево или направо будут продвигаться расчеты.

---

> 13.mkv

Следующим оператором будет вычитание. Ожидаемый знак минус в бинарной
форме дает нам предсказуемый результат... Вычитание отрицательных
чисел так же соответствует математическим правилам. Перестановка
операндов, в отличии от случая с суммой, дает новый результат... Но
так как мы можем использовать показатели знаков, то любое вычитание
положительного числа В из положительного числа А вы можете представить
в виде суммы отрицательного В с положительным А. Если хотя бы один из
участников операции оказался дробным - результат так же будет дробью.

Кстати, я не говорил? Мы можем присваивать результат операций в
переменную. Так как все операторы в конце-концов дают одиночное
значение, мы можем их использовать в любом месте, где было бы
корректным использование самого значения. Вместо переменной, равной
десяти, мы можем создать переменную равную сумме двух и
восьми. Результат одинаковый - интерпретатору нет разницы, как вы
получили значение. Он просто рассчитывает его и сохраняет. Полученные
переменные мы можем использовать для дальнейших расчетов... Если
промежуточные шаги нам не важны, мы можем постоянно перезаписывать
значение единственной переменной, будто накапливая значение.

Приоритет у сложения и вычитания одинаковый, направленность - слева
направо. Так что использование сложных операций будет достаточно
предсказуемым ...

---

> 14.mkv

А теперь умножение. Оно использует символ звездочки. Все правила
остаются такими же. Единственное отличие - приоритет умножения выше,
чему у сложения и вычитания. Потому два плюс два умножить на два - это
шесть, а не восемь. Хотя, если вы помните уроки математики в школе -
это официальное арифметическое поведение, а вовсе не попытки усложнить
вашу жизнь. Если вы желаете наклонить чашу весов в сторону сложения -
просто воспользуйтесь скобками. Посмотрите на следующую операцию... -
теперь у нас получилось восемь. Мы заставили интерпретатор рассчитать
сумму и только потом приняться за умножение.

Да, кстати, умножение на один - ничего не меняет. Умножение на ноль
всегда дает ноль. А вот умножение на дробное число всегда даст дробь,
даже умножение на дробный ноль! Хотя и это поведение точно такое же,
как у предыдущих операторов.

---

> 15.mkv

И деление. для него мы будем использовать слеш. Приоритет у деления
такой же, как у умножения. Существенными отличиями от предыдущих
операторов можно считать два факта. Деление всегда дает в результате
дробь, даже деление один на один. И делить на ноль нельзя, это
закончится ошибкой. Попробуйте поэкспериментировать, совмещая все
изученные варианты и привыкая к приоритету.

---


Эти четыре оператора вам должны быть знакомы еще со школьных парт. И
теперь вы уже можете извлечь небольшую пользу из полученных навыков
программиста. Но данных операций все же маловато. Как возводить числа
в степень и извлекать корни? Как округлять? Возможности операторов, на
самом деле выходят далеко за рамки четырех простейших операций, так
что советую сделать пару бутербродов и приготовиться к следующему
погружению.

---

> 16.mkv

Теперь начинаются необычные операторы. Как думаете, что могут делать
два слеша? Выглядит как делить-делить. Ну прям оооочень делить. Прежде
чем мы узнаем правду, хочу уточнить, что это самостоятельный оператор,
хот и выглядит, как два отдельных символа деления. В отличии от
скобок, между этих символов вы не должны ничего писать или даже
ставить пробелы - иначе он действительно превратиться в два отдельных
оператора деления. Такое правило актуально для всех операторов
состоящих из нескольких символов. Исключение составляют только
разновидности скобок, внутри которых как раз и стоит что-то писать.

Этот оператор действительно связан с делением. Его можно назвать
"деление с округлением в меньшую сторону". В зависимости от операндов,
результат может обладать немного отличающимися характеристиками, но
название всегда будет отражать главную идею происходящего.

Сначала целые числа. Если оба аргумента - не дроби, результатом будет
целое число. Сначала мы делим одно значение на второе, потом округляем
в меньшую сторону.

Второй случай - отрицательный результат. Если один из операндов -
отрицательное число, результат тоже будет отрицательным. Но не
забывайте, что для отрицательных чисел меньшим считается то, которое
дальше от нуля. То-есть минус четыре - меньше, чем минус три. С этой
информацией попытаемся разделить минус десять на 3. Без округления
результатом будет минус три целых и еще треть. Теперь нам нужно
округлить в меньшую сторону - выбираем между тремя и четырьмя. Для
положительных чисел мы бы остановились на тройке. Но так как мы левее
нуля по числовой оси, отрицательная четверка будет меньшим
значением. Значит, это и есть искомый результат.

В дальнейшем мы столкнемся с еще несколькими формами округления -
постарайтесь запомнить стратегию используемую в каждом из случаев.

И третий случай. Один или оба операнда - дроби. В этом случае мы
продолжаем получать число, округленное в меньшую сторону. Но
особенность в том, что нулевая дробная часть не отбрасывается. Зачем
это нужно, если справа от точки все-равно ноль? Для тех случаев, когда
вы записываете комплексное выражение и вам очень нужно получить дробь
в результате.

А теперь, попытайтесь вычислить остаток от деления ста на 17. Не в
уме, а с помощью интерпретатора, используя то, что мы успели сегодня
узнать. Поставьте видео на паузу и не продолжайте просмотр, пока у вас
не получится правильный ответ.

---

> 17.mkv

А теперь моя версия. Остаток от деления - это разница между делимым и
ближайшим числом, которое можно разделить нацело на делитель. Например
105 и десять. Нацело мы можем разделить 100 на десять. Разница между
105 и 100 равна пяти. Вот и искомое.  Но не будем же мы в уме
подсчитывать подобное значение. Пусть этим займется
интерпретатор. Нужно подумать. Если мы делим 105 на 10, то получим
10.5. Если бы число делилось на десять нацело, то в результате не было
бы дробной части. В этом случае мы можем сделать и обратное
заявление - если результат без дробной части, то он был получен
делением нацело. Используем наш последний оператор. Делим 105 на
десять с помощью двух слешей. Получаем 10. умножаем полученную десятку
на исходную - получаем сто. Вот то искомое ближайшее значение. Если вы
запутались - можете пересмотреть этот фрагмент несколько раз.

Теперь проворачиваем этот трюк с нашими значениями 100 и 17. Делим с
округлением... выходит пять. Теперь умножаем пять на 17... -
получаем 85. Вычитаем это значение из ста - видим остаток - 15. Но
хотелось бы покороче. Попытаемся совместить в одно выражение.

Берем округленное деление и умножаем на делитель... полученный
результат вычитаем из оригинального числа... Как видите, не слишком уж
сложно, но все же повторение этого трюка будет утомлять. Потому мы
добавляем в свою копилку еще один оператор - остаток от
деления. Выглядит он как символ процента. Применяем его... Гораздо
проще!

Теперь мы можем запросто рассчитать остаток от деления чего угодно на
что угодно. Попробуем пару раз и уточним детали...

Приоритет такой же как и у умножения. Кстати, то же самое касается
деления с округлением. Остаток от деления меньшего числа на большее -
всегда само меньшее число. Это и логично -  нельзя 10 разделить
целое число раз на 100. Кроме того, вы можете рассчитать остаток от
деления дробного числа или от деления НА дробное. Правило расчетов
прежнее - мы берем ближайшее число, которое делится без остатка, после
чего высчитываем его разницу с делимым. В конце-концов, остаток от
деления отрицательных чисел. Возможно результат вас удивит... А теперь
применим нашу формулу... и увидим, что формула продолжает
работать. Так что это не ошибка, а весьма корректный рассчет.

---

> 18.mkv

И возведение в степень. Думаю, оно будет наиболее простым среди
последних трех операторов. Для данного действия мы используем два
идущих подряд знака умножения... Крайне просто, да? Учтите, что
приоритет у возведения в степень пока что наибольший. Например,
пытаясь выполнить следующую операцию, интерпретатор сначала получит
степень и лишь потом выполнить умножение и деление.

Оператор извлечения корня... нет такого. С одной стороны, внезапно. С
другой - не забываем о математике. Извлечение корня - это возведение в
дробную степень. То-есть, для квадратного корня нам нужна степень
0.5. Попробуем...  А что насчет кубического корня?... Тут мы немного
прогадали со степенью - нам нужна одна третья, а три десятых это не
совсем то. Посмотрите, что получается при делении единицы на
три... попробуем такую степень...  вот теперь другое дело. Думаю,
проще было бы записать нечто подобное ... но мы забыли про приоритет!
Сначала мы возводим число в первую степень, а потом делим результат на
три. Для достижения правильного результата нам придется сломать
интерпретатор. А лучше - просто навяжем ему свое мнение с помощью
скобок...

Так что не стесняйтесь подходить к вопросу творчески - синтаксис тут
до неприличия логичен и множество сложных вещей можно записать
неожиданно простым образом.


---

> 19.mkv

И последний рывок с операторами. Сложные операторы. Угрожающе звучит,
но в реальности все элементарно. Представляем ситуацию. У вас есть
число. Вам нужно прибавить к нему пять. Потом 20. Потом делить
на 3. Все это мы сопровождаем перезаписью оригинальной
переменной. теперь уменьшим на единицу. Так вот, сложные операторы
позволяют сделать это немного проще. Мы убираем дублирующееся название
переменной справа от символа равно. Потом переносим оператор
левее. Знакомьтесь - это сложный оператор сложения. Его задача
изменить значение переменной на месте, уменьшая количество
повторяемого кода. Сначала происходит расчет нового значения, после
чего этот результат записывается в старую переменную. Подобная версия
существует у всех изученных нами бинарных операторов.

Вычитание...

умножение...

деление...

возведение в степень...

остаток от деления...

деление с округлением...

И да, сложные операторы - это полноценные атомарные операторы. Все их
символы должны быть написаны неразрывно. Попытка добавить пробелы
приведет к ошибке.


---


Вот мы и дошли до крутой темы! И тема эта - функции!

Функция - это нечто вроде законсервированного действия. В момент
активации, или вызова, действие, предполагаемое функцией, начинает
выполняться. Особенности выполнения зачастую можно контролировать с
помощью параметров, или же аргументы, функции, указанных, а точнее -
переданных, в круглых скобках рядом с вызываемой функцией. Функция в
python - это выражение. Она имеет значение, которое остается на месте
вызова. Принято говорить, что функция возвращает значение. Некоторые
фукции возвращают значение None. Обычно, такие функции вызывают ради
побочных эффектов.

Фууух... А теперь подробнее. Если бы вы могли словами переворачивать
блины на сковородке, эти слова и были бы функциями. Вы либо
определяете свое действие, либо пользуетесь уже готовыми определениями
для того чтобы потом его использовать множество раз. Создавать функции
мы пока не будет, а вот воспользоваться чужим трудом никто нам не
помешает. Но сначала рассмотрим общую форму работы.

Функция - это некое, действие. В общем-то, это почти тип
данных. Почти, потому что на самом деле функция это скорее возможность
неких данных выполнять действия. пока остановимся на первом
утверждении и не будем думать о том, что оно не совсем корректно.

Так вот. Функция - это действие. Но действие осязаемое, которое можно
сохранить в переменную. Выходит, если мы используем в коде переменную,
которая содержит функцию, интерпретатор подставит саму функцию на это
место.

Сама функция - это нечто весьма пассивное. Ее можно присваивать в
отдельные переменные, но у вас только появится бесполезный мусор. Для
полезного результата нам нужно функцию активировать - заставить
выполниться то действие, которое она символизирует. Такой процесс
активации называют вызовом функции. Для вызова вам нужно добавить пару
круглых скобок после функции.

---

> 20.mkv

Попробуем с одной из встроенных функций - exit. Сама по себе эта
переменная просто выводит небольшую справку об использовании.

Теперь добавляем пару круглых скобок и получаем результат - мы
покинули интерпретатор. Кстати, exit продублирована в переменную с
именем quit. попробуем закрыть интерпретатор с ее помощью...

---

Наиболее близки функции к командам в консоли. А значит, у них тоже
должны быть аргументы! В общем, именно так все и работает. Но тут
аргументы принято писать внутри круглых скобок - не стоять же им там в
одиночестве.

В зависимости от функции аргументы меняются, так же, как и в
консоли. Но учтите, если вы хочть чуть ошибетесь с аргументами - все
завершится ошибкой. Детали будут разобраны в недалеком будущем, а пока
просто запоминайте, как использовать существующие функции и старайтесь
не отклоняться от инструкций.


---

> 22.mkv

Сначала мы пишем имя функции, потом круглые скобки. Внутри скобок
записываем аргументы. Если аргументов нет - скобки пустуют. Один
аргумент записывается без изменений. А вот если аргументов больше - мы
по прежнему размещаем их внутри скобок, но обязательно отделяем друг
от друга запятой. Запятая - это оператор, потому пробелы вокруг можно
ставить в любой форме. Стандарты предписывают не ставить пробелов
перед запятой, а вот после - один пробел не помешает.

Точно так же как и сложение, вызов функции - это выражение. Что
означает, что вызов функции проходит через этап упрощения и на его
месте оказывается одно значение. Это значение называют возвращаемым. А
еще лучше будет сказать, что функция возвращает значение. Например,
функция int - по совместительству это внутренне название типа целого
числа в python. Если ее вызвать без аргументов, она вернет ноль, как
простейшее число. А если ее вызвать с аргументом, она попытается этот
аргумент превратить в целое число. Вызов с целым числом изначально не
дает никакого эффекта, а если передать в аргумент дробь... происходит
отбрасывание дробной части. Не округление в меньшую сторону, а именно
отбрасывание. Давайте посмотрим на несколько примеров... В случае
отрицательных чисел заметно отличие от оператора деления с
округлением. Вот вам и второй вариант округления в python.

Подобным эффектом обладает функция float. но она является
представителем дробных чисел, так что все переводит в дробь или же,
если аргумент не указан, возвращает дробный ноль. Перевод целых чисел
в дробные сопровождается добавлением пустой дробной части, так что
смотреть тут не на что.

---

Подобных функций-типов мы встретим достаточно много. Если быть более
точным - под каждый тип данных существует функция. Не все они столь
просты в использовании, вынужден заметить, но они есть всегда. Если
есть желание прокипятить мозг, то подумайте о том, что функция - это
тоже тип данных. значит, должна быть функция, которая представляет
функцию. А раз есть такая функция - должна быть функция представляющая
функцию для представления функции. Это очень классная мысль, особенно
если учесть, что дела именно так и обстоят. Но это уровень немного
выходящий за пределы нашего курса.

---

> 23.mkv

теперь несколько полезных вариантов. Функция max -  возвращает
наибольший из полученных аргументов. Интересная особенность - у нее
неограниченный список аргументов. то-есть мы можем передать 2, 3, 100,
200 аргументов и она будет работать! Минимальное количество аргументов
будет 2. Есть вариант с одним аргументом, но мы пока до него не
доросли.

Выберем наибольшее значение из нескольких положительных чисел...

или нескольких отрицательных...

или нескольких дробных...

да и вообще, давайте все перемешаем...

---

> 24.mkv

Есть и обратная функция - min. Она выбирает наименьшее число из
множества. Только учтите, размер определяется не дробностью, а
положение на числовой оси. То-есть, минус один будет меньше, чем минус
одна десятая. Парочка примеров...

---

> 25.mkv

И еще немного математики - функция abs. Она возвращает абсолютное
значение своего аргумента. Человеческим языком - она возвращает
положительную версию числа. Для любого значения больше нуля - это само
значение. Для отрицательных чисел - положительная версия этого числа.

---

> 26.mvk

Ну и еще один вариант округления - round. Укажите в аргументах дробное
число и получите округленную версию. Ничего сложного. О, вспомнил!
Округления бывают самыми разными, причем не только в python. Так вот
тут используется банковская версия. дробная часть меньше пяти десятых
округляется в меньшую сторону. Большая - в большую. А пять десятых
направляются в сторону ближайшего целого. Давайте посмотрим на это в
деле...

Между прочим, во-второй версии python используется более привычная
версия округления - можете сами посмотреть...

И еще одна форма этой функции - два аргумента. Второй аргумент, если
указан, уточняет знак после запятой, до которого должно произойти
округление. Как повелось, давайте посмотрим на все это в действии..

---

> 27.mkv

Так же, просто для расширения функционального запаса, стоит обратить
внимание на функцию pow - она возводит свой первый аргумент в степень,
указанную вторым аргументом. Результаты вполне корректны, но с учетом
существования отдельного оператора под это действие, ценность
 функции существенно падает.

---

> 28.mkv

И еще одно семейство функций. Каждая из них принимает в аргумент число
и возвращает его текстовое представление в другой системе
счисления. bin - переводит число в двоичную систему... oct - в
восьмеричную... hex - в шестнадцатеричную. Каждая из этих функций
формирует также необходимы префикс ноль-буква перед числом. Тут,
кстати, в аргументы подойдут только целые числа. Даже попытка
использовать одну целую ноль десятых закончится ошибкой.

---

> 29.mkv

И последняя на сегодня функция - print. Она выводит свои аргументы на
экран. Полюбуемся...

Я знаю, что это не кажется полезным, но в реальности это не так. Те
значения, которые вы видите после выполнения каждой строки появляются
на экране только благодаря тому, что работа происходит в
интерпретаторе. Обычно его запускают для тестирования, потому многие
процессы в нем приводят не к самому стандартному результату. В
реальной программе никогда не происходит вывода данных до тех пор,
пока вы не потребуете этого явно. Например, функцией print. Она,
кстати возвращает специальное значение None - увидеть его, правда,
пока не получится. Но оно есть - честное слово. Это специальное
значение для указание на отсутствие значения. Знаете, после таких
заявлений я думаю, что не все программисты адекватные.

Попробую доказать полезность print. Для этого нам придется написать
свой первый скрипт. Создайте обычный текстовый файл с расширением
py. В общем-то, расширение вовсе не критично, но так принято.

После чего мы пишем что-то привычное в этом файле. создадим пару
переменных. И, наконец, запускаем этот скрипт. Переходим в терминале -
системном терминале, а не интерпретаторе python - в директорию с вашим
файлом и выполняем команду python имя файла...

Ничего! Не работает. Или работает? Я же только что говорил, что
программа ничего не выведет без вашего содействия. Попробуем создать
ошибку...


О, теперь видно, что работает. Точнее, не работает, но это признак
того, что все, в общем-то, вполне работает. Исправим ошибку и добавим
print...

Совсем другое дело. Количество инструкций вывода в вашем скрипте не
ограниченно, так что можете свободно экспериментировать и
развлекаться. Кстати, количество аргументов в print тоже неограниченно - все
они будут выведены через пробел. А если вы присвоите результат print в
переменную - у вас появится возможность увидеть None.

---

Знаете, это было непросто - все очень запутано. И я просто устал уже
рассказывать о непонятных вещах. Если вы умудрились разобраться, как
оно работает - начинайте считать. Как насчет того, чтобы написать
код, который будет вычислять квадратные уравнения. Сначала, наверное,
придется загуглить, что это такое... но у вас есть время, пока я
высплюсь и наберусь сил для нового урока
