# Лекция 6

(Говорящая голова)

И снова привет. Сегодня я постараюсь не сильно вас мучить и не
рассказывать чересчур много о новых возможностях и конструкциях в
программировании. Вместо этого давайте-ка более подробно рассмотрим то
что уже успели изучить и попытаемся разобраться и объяснить некоторые
особенности поведения наших программ.

Начнем мы с абстракцией которую я упоминал ещё на первых
занятиях. Помните, я рассказывал про коллекции, про типы данных
которые состоят из множества самостоятельных значений . Эти типы
данных можно разбить на категорию по самым разным критериям и я
стремился разделить всё на две противоположные категории. Например,
однородные и неоднородные коллекции, изменяемые и неизменяемые, и так
далее. Касательно однородности пока ничего специфического сказать
нельзя. В зависимости от типа данных однородность или обязательна или
нет. В случае строк — однородность избежать нельзя. Строка - это
коллекция символов , то есть каждый элемент строки - это символ и
значит строка однородна. В списках же у вас нет каких-то конкретных
требований к типу содержимого.  Вы можете создать список чисел, строк,
других списков , но я просил вас стараться создавать однородные
списки. Это всего лишь моё пожелание, а не какое-то обязательное
требование языка . Так что списки — неоднородны.

 А вот в изменяемости всё обстоит несколько сложнее — она также
 является некой абстракцией с различными толкованиями, но имеет
 гораздо большее влияние на то как вы пишите код и на возможности
 отдельных типов данных. Если попытаться сделать всё очевидным то
 можно сказать что изменяемые типы данных поддерживает модификация , а
 неизменяемые типы данных постоянны и не могут быть модифицированы.  А
 вот что же это значит на практике мы сейчас попробуем увидеть

(видео конспект)

https://drive.google.com/open?id=1pUAvgP-32akTcYqKmgbdCp4PsYIHroDK
Изменяемые значения ---


(Говорящая голова)

Так что списки и строки чем-то похожи. в частности: и то, и другое —
это коллекция. Если вы создадите с список в котором каждый элемент
будет одной буквой , то грань практически стирается — и то и другое
становится коллекцией символов. Но мы увидели и различия - списки
изменяемы, благодаря чему у них есть некоторые особенности поведения ,
должен сказать, весьма неожиданные.  Также в списке могут содержаться
неоднородные значения, что, в принципе, отходит на задний план — так
как не скрывает никаких побочных эффектов. Что же ещё могут делать
списки из того что мы видели внутри строк?  Начнем наш краткий
анализ...

(видео конспект)

https://drive.google.com/open?id=1SmyWVTZl9Zkknf02nRPcHlzqfPKopJxp
сравнение ---


(Говорящая голова)

Прекрасно . И снова вернемся к изменяемости. Выходит, имея на руках
 некий список Х который вы ради эксперимента ещё присвоили и в
 переменную Y, на деле у вас единственный список.  Изменение одной
 переменной целиком и полностью отражается на содержимом второй
 переменной. Это достаточно неудобно . Представьте что у вас есть два
 яблока . Вы дали одно другу и он, разумеется, съел это
 подношение. Что вы вряд ли захотите увидеть, так это уменьшение в
 размерах того яблоко которое осталось у вас. Нечто похожее происходит
 в питоне на первый взгляд. Для начала разрушен это
 представление. Если проводить более точно аналогию питона , то у вас
 есть одно яблоко и вы его отдали другу. Просто теперь этого яблока 2
 название . Во-первых, это яблоко друга . Во-вторых, это вроде бы
 изначально ваше яблоко. Теперь становится понятным, почему друг
 поедает свое яблоко, поедает ещё и ваше. Чтобы проблемы решить нам
 нужно умудриться клонировать наше яблоко и получить два
 самостоятельных и независимых экземпляра, которые только выглядят
 одинаково.  Пожалуй стоит переключиться обратно на списке и
 попробовать сделать это в интерпретаторе.

(видео конспект)

https://drive.google.com/open?id=1uj8OZS-FEjlB6zSboKNM_0wKpNaMfDTq
Копирование ---

(Говорящая голова)

Следующая проблема. Списки — это изменяемый тип данных . Я могу
перезаписать первый элемент списка , второй, третий или любой элемент
который в списке присутствует. Если очень захочется, то я могу даже из
списка что-то удалить. А как новый элемент добавить? Как присоединить
концу списка ещё пять элементов. Как вставить перед коллекцией из
нескольких чисел коллекцию из нескольких слов? В конце концов, как
раздвинуть элементы списка и между ними поместить другую
коллекцию. Наивные попытки выполнять модификации с помощью простых
индексов приведут вас вовсе не к желаемым результатам. Вы либо будете
перезаписывать существующие элементы, либо получать ошибки. И вот что
вам нужно сделать для того чтобы достичь желаемого...

(видео конспект)

https://drive.google.com/open?id=1yLx5_1VwXGT2fTWiEt7oFRyCymJLKIX2
модификации ---

(Говорящая голова)

Обсуждая строки мы столкнулись с непонятным и мало полезным методом
разбиения строки на фрагменты.  Сейчас мы знаем что в результате этот
метод даст нам список.  Но разбивать строку на отдельные слова — это
не всегда наша цель . Иногда задача может оказаться более
нетривиальный — нам нужно игнорировать предлоги и союзы, или разбиение
нужно выполнять по одному из возможных разделителей, или мы даже не
знаем заранее по какому символу нужно выполнять разделение строки,
вместо этого мы будем генерировать новые элементы в зависимости от
контекста и содержимого, которое мы уже прочитали. Приходим мы к тому
что метод split - слишком примитивный и негибкий - а значит нам нужно
уметь реализовать подобный функционал самостоятельно

(видео конспект)

https://drive.google.com/open?id=1_DqaS0Heinz7LtNn7qOdLCX4rSgw5DOg
Разбиение на фрагменты ---

(Говорящая голова)

Это прекрасно, что мы можем так легко разбить строку на фрагменты. Но
чтобы что-то сломать шибко умным быть не нужно . А вот чтобы собрать
обратно, чтобы всё выглядело не хуже — тут уже нужен определенный
навык. Во-первых мы можем использовать строчные методы, а именно join.
Он позволит нам объединить кусочки строки с помощью некого клея.
Весьма рабочий сценарий , но и тут не всё так прекрасно. Во-первых, мы
не всегда захотим объединять все слова с помощью одного и того же
фрагмента — между некоторыми словами нужно ставить пробел, между
другими знаки препинания , в некоторых словах нам нужен перенос строк.
Во-вторых , судьба может повернуться так , что склеивать в большую
строку нам придётся не отдельные слова а что-то совершенно иное,
например числа, списки, и всё что угодно, но не строки. Так что
пофантазируем немного на тему объединения фрагментов

(видео конспект)

https://drive.google.com/open?id=1eC9OSOeeuG_RcBYrooR0T7aEcaLWuyNj
объединение фрагментов ---

(Говорящая голова)
!!!!!!!!!!!!!!!!!!!!!!!!
Другой классической проблемой можно считать непредсказуемость
списков. До тех пор пока список одномерный, то есть не содержит
вложенных списков, с с каждым его элементам крайне легко выполнить
некую операцию. А если внутри одного списка вложен другой . или ещё
хуже внутри вложенного списка есть третий список, там есть четвертый и
таким образом продолжаться вся может очень долго. Написание линейного
кода ограничена тем что нам нужно предусмотреть возможность
существования каждого дополнительного уровня вложенности и описать
стратегию поведения на все случаи. Если у нас предполагается влажность
в 1000 уровней, то можно немного устать . Но мы же программисты — мы
должны уметь писать программы любой сложности. И вот нам на помощь
снова приходит отличная штука , которую называют абстракция. Вам нужно
немного отойти от своего кода и посмотреть на него
издалека. Попытайтесь заметить схожие части. Если нам нужно обработать
все элементы списка, там и цикле проходим все элементы. Если внутри
нашего списка есть другая коллекция, то Мы возвращаемся в самое начало
нашего алгоритма — нам нужно обойти эту коллекцию в цикле и выполнить
для каждого элемента какую-либо операцию. Если внутри вложенного
списка обнаружится ещё один список, мы заново применяем для него весь
наш алгоритм. Таким образом мы приходим к тому что наш код должен
применять сам себя к вложенным спискам. Это называют рекурсией. Вот
как она реализуется в циклах

(видео конспект)

https://drive.google.com/open?id=1tGSsWugogWZ33Gdwl0bdVS9suX8YLGWp
рекурсия ---

(Говорящая голова)

Я тут подумал, Если списке строки настолько похожи , то неужели никто
не додумался создать у списка несколько методов для упрощения нашей
жизни. Таки додумался!  Так как списки более абстрактны и
неопределённы, методов у них значительно меньше чем у строк и задачи
этих методов достаточно очевидны.  Более того, Мне кажется что все эти
задачи мы сегодня успели реализовать. Но Давайте всё же заглянем
внутрь списка

(видео конспект)

https://drive.google.com/open?id=1T3YQqgF6gUFHIpN3HaFEQPlKwQRfnwcZ
методы ---

(Говорящая голова)

Модификация списков с помощью методов крайне удобнa. заметьте Как
меняется акцент кода — вместо того чтобы выполнять абстрактные
операции над переменными, мы вносим команду, которая заставляет саму
переменную что-то с собой сделать.  Таким образом мы уменьшаем
количество абстракции, Что приводит к упрощению понимания. Это не
просто Случайный действия , это задачи которые стоят перед вашими
коллекциями и более того, эти задачи является специализацией ваших
коллекций. А потому уже не нужно гадать, что может делать метод с
названием создать_продукт.  Если перед вами объект-парикмахер, то
продуктом будет новая причёска. Если объект-Пекарь, то продуктом будет
новая кондитерскoe изделиe.  Вернемся к спискам и досмотрим , Что ещё
они умеют

(видео конспект)

https://drive.google.com/open?id=1ry32c1MXY5pZtyitwEYbO8_8n_RPCcLb
методы 2 ---

(Говорящая голова)

И последняя возможность списков — это сортировка. Чтобы вам каждый раз
не приходилось писать кучу циклов, чтобы не мучаться выбором
наилучшего алгоритма для сортировки, тут уже всё решено за вас . Вам
Остаётся только настроить несколько незначительных деталей и запустить
этот увлекательный процесс сортировки, который кстати пройдет за
ширмой и вы просто получите готовый результат . Даже немного грустно
... Зато очень просто - давайте-ка побыстрее это применим на практике

(видео конспект)

https://drive.google.com/open?id=1RK-iC0TTtwNp7Oyus5m9enmn2uAQQXBB
сортировка ---

(Говорящая голова)

Вот, пожалуй и всё на сегодня. Как я и обещал, о совершенно новых
идеях и методиках и я не рассказывал. Но даже просто разбирая более
подробно то что мы уже изучили можно узнать столько нового. Надеюсь
это побуждает вас тягу к экспериментам и поискaм, потому что только
написав очень-очень-очень много кода , можно научиться делать это
действительно хорошо одно лишь теории не бывает достаточно, во всяком
случае, в Вeб-разработке. Постоянно появляется что-то новое и только
стремление знать всё и искренний интерес к тому с чем вы работаете
позволяет вам быть на волне. Но вы заслужили свои выходные , Так что
до следующей встречи можете валяться под одеялко и ничего не
делать. Ах да, отдыхать стоит только после выполнения тестов , потому
посмотрите что я там вам приготовил быстренько посёлка идти все задачи
как орешки, А потом уже действительно идите отдыхать. Желаю вам удачи
в тестах. Пока