# Лекция 13

(Говорящая голова)

И снова привет. Как обстоят дела с созданием модулей? Надеюсь, слишком
сложный предыдущая тема не показалaсь, потому что сегодня мы
углубляемся ещё больше в объектно-ориентированное программирование и
Разбираем уже не Как пользоваться готовыми решениями, А Как
настраивать абсолютно любой Аспект поведения объектов под свои
нужды. До этого дня мы встречали множество разных типов данных, каждый
из которых не просто представлял группу схожих элементов, но и
обеспечивал специфическое поведение для большинства стандартных
операций. Например, числа складываются по правилам арифметики, строки
вместо этого — просто объединяются в одну большую строку, а списки
создают новую коллекцию , объединяющую все элементы исходных
значений. Некоторые типы данных можно использовать в виде индексов,
как например целые числа и срезы. Некоторые элементы могут быть
ключами словаря. Другие — могут перебираться в цикле. Абсолютно любое
подобное поведение можно строить и вашим собственным типом данных, Так
что считать что у существующих значений есть какие-то магические
особенности будет в корне неверным. Всё что уже есть в питоне, вполне
можно реализовать и своими руками.  Благодаря этой возможности мы
получаем множество разнообразных значений, которые могут участвовать в
схожих операциях. Это явление называют полиморфизмом , и именно ему мы
посвящаем сегодняшний урок.

(видео конспект)

https://drive.google.com/open?id=1arcDkRxzfFH47V4C3MI0PouRCRpwgULr  Строчное преобразование


----------------------------------------------------------------

(Говорящая голова)

Как видите, в том чтобы заставить питон подчиняться вашим требованиям
Вовсе нет ничего сложного. И как я уже сказал, все методы,
обеспечивающие полиморфизм, начинается с двух нижних подчеркиваний и
заканчиваются имя же. Чаще всего, название таких методов будет
состоять из одного словa, возможно, сокращение , чтобы уложиться в 2-4
буквы. Есть несколько исключений из этой традиции , А некоторые
специальные методы даже состоят из двух слов, но такое встречается
крайне редко. Некоторые методы для полиморфизма, вроде преобразование
в строку, определены по умолчанию во всех классах . Благодаря этому,
все объекты могут выводиться на экран. Другие же, например
преобразование в число, нужно определять явно. Если быть совсем
честным, то они тоже имеют дефолтный определение, но по умолчанию это
определение просто создает ошибку и вы видите сообщение, о том что ваш
объект не поддерживает данную операцию. Но нет в питоне ничего, что
нельзя исправить.  Экспериментируем дальше

(видео конспект)

https://drive.google.com/open?id=13T8QEta_GPc67UAR81N-XXfc-55Bj1SD Преобразование в другие типы


----------------------------------------------------------------

(Говорящая голова)

Ну преобразование — это далеко не единственная задача, выполняемая
подобными методами. Следующая группа задач — обеспечение разноплановых
взаимодействий между объектами. У нас есть инструменты для того чтобы
заставить объекты складываться, умножаться, вычитаться. Мы можем даже
заставить объект вести себя как функция. Все те виды взаимодействия
которые вы уже видели для базовых объектов , вроде чисел или строк,
также реализуемые для наших собственных типов данных. И описывается
подобное поведение не намного сложнее чем ранее рассмотренная
преобразование.

(видео конспект)

https://drive.google.com/open?id=1YenWT-Dp6hfRC6TxCz-YZb_hraH4DC3y сложение

----------------------------------------------------------------

(Говорящая голова)

Прежде чем мы перейдем на остальные арифметические методы, хочу ещё
раз заострить Ваше внимание на способе работы нового метода. Он
вызывается питоном неявно в тот момент, когда происходит сложение. Это
не какая-то особая ситуация для наших собственных типов данных, числа
из строки ведут себя точно так же. Оператор Plus используется только
для облегчения понимания, в реальности же всё обеспечивается
методами. То значение которое стоит слева от оператора становится
первым аргументом метода, значение справа от оператора становится
вторым значение метода. Таким образом методы описывающие поведение
операторов в большинстве своём принимают ровно два
аргумента. Возвращать эти методы могут всё что угодно. К примеру, если
вы сложите целое и дробное число — Вы получите дробь. То есть, слева
от оператора плюс стояло целое число , но это не помешало результату
операции получить тип левого операнда. В арифметических методах вы
вольны возвращать значение любого типа. Но ведь будет весьма странно
если сложение чисел выдаст в результате строку. Таким образом сам
здравый смысл нам подсказывает, что лучше Не отходить далеко от
изначальных типов данных. Двигаемся дальше

(видео конспект)

https://drive.google.com/open?id=1Ol7Cg__smMP76i--I9_sWnc8eqWV1R1d другие арифметические операции

----------------------------------------------------------------

(Говорящая голова)

Теперь заостряет внимание на Другой детали.  Вне зависимости от
используемого метода, Я всегда возвращал Новый объект массой. И важным
моментом здесь является то что возвращался именно Новый объект, ни
один из участников операции. Это весьма Разумное решение. Сами
подумайте если у вас складываются два числа A и B, Наверняка вы не
захотите чтобы после выполнения сложения Одно из значений
изменилось. Вместо этого вы хотите просто получить новый результат,
который в дальнейшем присвойте в удобную вам переменную. Именно
поэтому мы не записываем результат сложения или вычитания как величину
массы объекта слева от оператора. Вместо этого, мы всегда создаем
новый объект тем самым обеспечивая неизменность входящих данных. И всё
же, даже тут бывает исключение из правил. Возьмём сложные операторы —
в них предполагается что переменная, которая содержит значения, будет
изменено на месте. Как же быть в таком случае? Нужно просто
реализовать для сложных операторов свои методы. Внимание на экран

(видео конспект)

https://drive.google.com/open?id=1FGdevIKBAhkdGuRPWwOr3NW3PZ_9_7rt инкрементальные операторы

----------------------------------------------------------------

(Говорящая голова)

Надеюсь, этот фрагмент не породил никаких дополнительных вопросов. Как
вы могли заметить, правила очень просты — если существует только
базовый вариант метода сложения , вычитание, деление — то будет вызван
именно этот вариант , вне зависимости от того используете вы простой
оператор или сложный. Если же у вас есть две реализации методы —
базовая и снабженная префиксом i, то в зависимости от операции будут
вызваны соответствующим метод , что позволяет вам более тонко
контролировать используемые ресурсы и логика выполнения
операции. Разве можем пожелать ещё что-то? Да, вполне можем. И вот
чего нам не хватает.

(видео конспект)

https://drive.google.com/open?id=1Y48jEeUWJ2FZbLbMr1bsGdEs-pWWDxiQ правосторонние операторы

----------------------------------------------------------------

(Говорящая голова)

Одними числами сыт не будешь, потому нам обязательно захочется создать
более экзотический тип данных. Если подумать, то наиболее часто мы
встречали коллекции. Чтобы нечто можно было считать коллекцией - это
нечто должно содержать в себемножество элементов. Как мы узнаем, что
элементов действительно много? Верно, посчитав их. А значит, нам нужно
вычислять длинну коллекции. Кроме того, имеяя только размерность,
далеко не уедешь. Придется реализовать какой-то способ перечислить все
элементы, которые в нашу коллекцию входят. Для этого мы освоим еще два
метода

(видео конспект)

https://drive.google.com/open?id=1TY8vxDtWEcJFeemrUnG3qKJkDQzbL7nu Базовые коллекции

----------------------------------------------------------------

(Говорящая голова)

А если вы всё же захотели сделать свою коллекцию ещё больше похожие на
список либо словарь . Если вам принципиально важно добавить в вашу
коллекцию поддержку квадратных скобок. Да нет никаких проблем — даже
это вполне реализуемо. Но прежде чем мы начнем писать код, Давайте
вспомним , Что именно Нам позволяет сделать квадратные
скобки. Простейшие действия — это извлечение элементы из коллекции
. Мы пишем переменную с коллекцией после Чего стоим квадратные скобки
с индексом и получаем значение. Вторая ситуация — это запись
значения. Весьма похожа на предыдущую, но после конструкции с
квадратными скобками стоит символ равно и значение которое должно
присвоиться в соответствующий индекс. Если вам кажется что разницы
нет, вспомните что произойдет при попытке извлечь из словаря
несуществующий ключ. Это завершится ошибкой. Если же вы попытаетесь
присвоить в несуществующий ключ, да всё пройдёт успешно. Таким образом
мы приходим к выводу, что запись и извлечениe — это абсолютно разные
операции. И последняя возможна операция — это удаление элемента. Она
отличается от записи тем, что мы не просто присваиваем в некий ключ
пустое значение, Мы полностью уничтожаем ключ в коллекции. С этими
данными можно начинать писать код

(видео конспект)

https://drive.google.com/open?id=1tqDq39eDPAHh8NbTQPjmBCSZNWnrfZXr Полноценные коллекции

----------------------------------------------------------------

(Говорящая голова)

Существует еще множество разнообразных методов для модификации
поведения, но большинство из них обладает достаточно загадочными
особенностями используется крайне редко. Так что предлагаю завершать
это путешествие. Напоследок расскажу ещё пару-тройку секретов который
Вы будете использовать каждый день. То есть, самая вкусная осталось
напоследок. Вспомните наши проблемы предыдущих занятий — когда мы
создаем объект класса, нам этот объект нужно как-то настроить. Делать
Это мы можем с помощью создания новых свойств. Либо мы добавляем эти
свойства в объект явным образом после создания , прямо в глобальном
коде, либо мы реализуем метод, вызывая который мы определяем сразу все
необходимые настройки. Второй вариант гораздо более удобный, Я надеюсь
что вы тоже так думаете. Но всё же тратить две строки на создания
одного объекта кажется не совсем правильным. И с помощью того что мы
сейчас рассмотрим , задачу можно решить в 1 действие.

(видео конспект)

https://drive.google.com/open?id=1vmrumrsdhwHdsWszqAMP0FwX5Kx2GEtn Конструктор

----------------------------------------------------------------

(Говорящая голова)

И последнее на сегодня фрагменты, А значит и последняя группа
методов. Действие, которое допустимо для каждого значения, каждого
типа данных, и которые не грех реализовать даже нам. Это операторы
сравнения. Всё что касается сравнение двух значений — равенство ,
больше-меньше , неравенствo — всё это входит в следующую категорию. И
для описания всех возможных комбинаций У нас существует целых шесть
методов.  Глубоко вздохнули и сделали последний рывок

(видео конспект)

https://drive.google.com/open?id=1v4yck3D6XqP_WF3fkRHGe9FC7vN24oGW Равенство


----------------------------------------------------------------

(Говорящая голова)

Вот мы разобрались с тем, что из себя представляет полиморфизм.
Звучит И правда гораздо страшнее, чем выходит на самом деле. До тех
пор пока у вас есть твердую уверенность в том, что вы можете изменить
любое поведение ваших объектов, и у вас есть знание того как это
сделать, никаких проблем с полиморфизмом вас возникнуть не должно.
Изменение поведения также не является чем-то эзотерическим — вы просто
создаете метод, которое вызывается в момент применения определенной
операции. Это либо некий этап в жизни объекта, как в случае
конструктора, или же взаимодействия с оператором , как в случае
большинства рассмотренных методов. Все встроенные типы данных
реализуют точно такие же методы, все библиотеки которые вы будете
устанавливать используют Точно такую же систему. Таким образом вы
всегда можете самостоятельно написать тот функционал , который видите
в установленном модуле. Я всё же посоветую стремится использовать
чужой код ее выполняет лишнюю работу, но просто для развлечения вполне
можно пытаться переписать чужие решения на свой лад. И не пытайтесь
запомнить сразу все возможные методы модификации поведения — ночь, что
поведение можно изменить, А название метода вы всегда сможете найти в
интернете. Да и во многих случаях название крайней очевидны Так что их
можно просто угадать.  А сейчас выполняем контрольную работу ,
награждаем себя чем-то вкусным, и идем баиньки , потому что впереди у
нас последний и самый запутанный урок из секции
объектно-ориентированного программирования. До встречи на следующем
занятии