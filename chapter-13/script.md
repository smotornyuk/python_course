# Лекция 13

(Говорящая голова)

И снова привет. Как обстоят дела с созданием модулей? Надеюсь, слишком
сложной предыдущая тема не показалaсь, потому что сегодня мы
углубляемся ещё больше в объектно-ориентированное программирование и
разбираем уже не как пользоваться готовыми решениями, А как
настраивать абсолютно любой аспект поведения объектов под свои
нужды. До этого дня мы встречали множество разных типов данных, каждый
из которых не просто представлял группу схожих элементов, но и
обеспечивал специфическое поведение для большинства стандартных
операций. Например, числа складываются по правилам арифметики, строки
вместо этого — просто объединяются в одну большую строку, а списки
создают новую коллекцию, объединяющую все элементы исходных
значений. Некоторые типы данных можно использовать в виде индексов,
как например целые числа и срезы. Некоторые элементы могут быть
ключами словаря. Другие — могут перебираться в цикле. Абсолютно любое
подобное поведение можно настроить и вашим собственным типам данных,
Так что считать что у существующих значений есть какие-то магические
особенности будет в корне неверным. Всё что уже есть в питоне, вполне
можно реализовать и своими руками.  Благодаря этой возможности мы
получаем множество разнообразных значений, которые могут участвовать в
схожих операциях. Это явление называют полиморфизмом и именно ему мы
посвящаем сегодняшний урок.

(видео конспект)

https://drive.google.com/open?id=1arcDkRxzfFH47V4C3MI0PouRCRpwgULr  Строчное преобразование


----------------------------------------------------------------

(Говорящая голова)

Как видите, в том чтобы заставить питон подчиняться вашим требованиям
вовсе нет ничего сложного. И как я уже сказал, все методы,
обеспечивающие полиморфизм, начинается с двух нижних подчеркиваний и
заканчиваются имя же. Чаще всего, название таких методов будет
состоять из одного словa, возможно, сокращения, чтобы уложиться в 2-4
буквы. Есть несколько исключений из этой традиции, а некоторые
специальные методы даже состоят из двух слов, но такое встречается
крайне редко. Некоторые методы для полиморфизма, вроде преобразования
в строку, определены по умолчанию во всех классах . Благодаря этому,
все объекты могут выводиться на экран. Другие же, например
преобразование в число, нужно определять явно. Если быть совсем
честным, то они тоже имеют дефолтное определение, но по умолчанию это
определение просто создает ошибку и вы видите сообщение, о том что ваш
объект не поддерживает данную операцию. Но нет в питоне ничего, что
нельзя исправить. Экспериментируем дальше

(видео конспект)

https://drive.google.com/open?id=13T8QEta_GPc67UAR81N-XXfc-55Bj1SD Преобразование в другие типы


----------------------------------------------------------------

(Говорящая голова)

Ну преобразование — это далеко не единственная задача, выполняемая
подобными методами. Следующая группа задач — обеспечение разноплановых
взаимодействий между объектами. У нас есть инструменты для того чтобы
заставить объекты складываться, умножаться, вычитаться. Мы можем даже
заставить объект вести себя как функции. Все те виды взаимодействия
которые вы уже видели для базовых объектов, вроде чисел или строк,
также реализуемы для наших собственных типов данных. И описывается
подобное поведение не намного сложнее чем ранее рассмотренное
преобразование.

(видео конспект)

https://drive.google.com/open?id=1YenWT-Dp6hfRC6TxCz-YZb_hraH4DC3y сложение

----------------------------------------------------------------

(Говорящая голова)

Прежде чем мы перейдем на остальные арифметические методы, хочу ещё
раз заострить ваше внимание на способе работы нового метода. Он
вызывается питоном неявно в тот момент, когда происходит сложение. Это
не какая-то особая ситуация для наших собственных типов данных - числа
и строки ведут себя точно так же. Оператор Plus используется только
для облегчения понимания, в реальности же всё обеспечивается
методами. То значение которое стоит слева от оператора становится
первым аргументом метода, значение справа от оператора становится
вторым значение метода. Таким образом методы описывающие поведение
операторов в большинстве своём принимают ровно два
аргумента. Возвращать эти методы могут всё что угодно. К примеру, если
вы сложите целое и дробное число — вы получите дробь. То есть, слева
от оператора плюс стояло целое число, но это не помешало результату
операции получить тип правого операнда. В арифметических методах вы
вольны возвращать значение любого типа. Но ведь будет весьма странно
если сложение чисел выдаст в результате строку. Таким образом сам
здравый смысл нам подсказывает, что лучше не отходить далеко от
изначальных типов данных. Двигаемся дальше

(видео конспект)

https://drive.google.com/open?id=1Ol7Cg__smMP76i--I9_sWnc8eqWV1R1d другие арифметические операции

----------------------------------------------------------------

(Говорящая голова)

Теперь заостряет внимание на другой детали.  Вне зависимости от
используемого метода, я всегда возвращал новый объект массы. И важным
моментом здесь является то что возвращался именно новый объект, а не
один из участников операции - это весьма разумное решение. Сами
подумайте, если у вас складываются два числа A и B, наверняка вы не
захотите чтобы после выполнения сложения одно из значений
изменилось. Вместо этого вы хотите просто получить новый результат,
который в дальнейшем присвоите в удобную вам переменную. Именно
поэтому мы не записываем результат сложения или вычитания как величину
массы объекта слева от оператора. Вместо этого, мы всегда создаем
новый объект тем самым обеспечивая неизменность входящих данных. И всё
же, даже тут бывает исключение из правил. Возьмём сложные операторы —
в них предполагается что переменная, которая содержит значения, будет
изменено на месте. Как же быть в таком случае? Нужно просто
реализовать для сложных операторов свои методы. Внимание на экран

(видео конспект)

https://drive.google.com/open?id=1FGdevIKBAhkdGuRPWwOr3NW3PZ_9_7rt инкрементальные операторы

----------------------------------------------------------------

(Говорящая голова)

Надеюсь, этот фрагмент не породил никаких дополнительных вопросов. Как
вы могли заметить, правила очень просты — если существует только
базовый вариант метода сложения, вычитания, деления — то будет вызван
именно этот вариант, вне зависимости от того используете вы простой
оператор или сложный. Если же у вас есть две реализации метода —
базовая и снабженная префиксом i, то в зависимости от операции будут
вызван соответствующий метод, что позволяет вам более тонко
контролировать используемые ресурсы и логику выполнения
операции. Разве можем пожелать ещё что-то? Да, вполне можем. И вот
чего нам не хватает.

(видео конспект)

https://drive.google.com/open?id=1Y48jEeUWJ2FZbLbMr1bsGdEs-pWWDxiQ правосторонние операторы

----------------------------------------------------------------

(Говорящая голова)

Одними числами сыт не будешь, потому нам обязательно захочется создать
более экзотический тип данных. Если подумать, то наиболее часто мы
встречали коллекции. Чтобы нечто можно было считать коллекцией - это
нечто должно содержать в себе множество элементов. Как мы узнаем, что
элементов действительно много? Верно, посчитав их. А значит, нам нужно
вычислять длинну коллекции. Кроме того, имеяя только размерность,
далеко не уедешь. Придется реализовать какой-то способ перечислить все
элементы, которые в нашу коллекцию входят. Для этого мы освоим еще два
метода

(видео конспект)

https://drive.google.com/open?id=1TY8vxDtWEcJFeemrUnG3qKJkDQzbL7nu Базовые коллекции

----------------------------------------------------------------

(Говорящая голова)

А если вы всё же захотели сделать свою коллекцию ещё больше похожей на
список либо словарь? Если вам принципиально важно добавить в вашу
коллекцию поддержку квадратных скобок? Да нет никаких проблем — даже
это вполне реализуемо. Но прежде чем мы начнем писать код, давайте
вспомним, что именно нам позволяют сделать квадратные
скобки. Простейшие действия — это извлечение элемента из коллекции. Мы
пишем переменную с коллекцией после чего ставим квадратные скобки с
индексом и получаем значение. Вторая ситуация — это запись
значения. Весьма похожа на предыдущую, но после конструкции с
квадратными скобками стоит символ равно, значение которое должно
присвоиться в соответствующий индекс. Если вам кажется что разницы
нет, вспомните что произойдет при попытке извлечь из словаря
несуществующий ключ. Это завершится ошибкой. Если же вы попытаетесь
присвоить в несуществующий ключ, то всё пройдёт успешно. Таким образом
мы приходим к выводу, что запись и извлечениe — это абсолютно разные
операции. И последняя возможная операция — это удаление элемента. Она
отличается от записи тем, что мы не просто присваиваем в некий ключ
пустое значение, мы полностью уничтожаем ключ в коллекции. С этими
данными можно начинать писать код

(видео конспект)

https://drive.google.com/open?id=1tqDq39eDPAHh8NbTQPjmBCSZNWnrfZXr Полноценные коллекции

----------------------------------------------------------------

(Говорящая голова)

Существует еще множество разнообразных методов для модификации
поведения, но большинство из них обладает достаточно загадочными
особенностями и используется крайне редко. Так что предлагаю завершать
это путешествие. Напоследок расскажу ещё пару-тройку секретов которые
вы будете использовать каждый день. То есть, самое вкусное осталось
напоследок. Вспомните наши проблемы предыдущих занятий — когда мы
создаем объект класса, нам этот объект нужно как-то настроить. Делать
это мы можем с помощью создания новых свойств - либо мы добавляем эти
свойства в объект явным образом после создания, прямо в глобальном
коде, либо мы реализуем метод, вызывая который мы определяем сразу все
необходимые настройки. Второй вариант гораздо более удобный, Я надеюсь
что вы тоже так думаете. Но всё же тратить две строки на создания
одного объекта кажется не совсем правильным. И с помощью того что мы
сейчас рассмотрим, задачу можно решить в 1 действие.

(видео конспект)

https://drive.google.com/open?id=1vmrumrsdhwHdsWszqAMP0FwX5Kx2GEtn Конструктор

----------------------------------------------------------------

(Говорящая голова)

И последние на сегодня фрагменты, а значит и последняя группа
методов. Действия, которые допустимы для каждого значения, каждого
типа данных, и которые не грех реализовать даже нам. Это операторы
сравнения. Всё что касается сравнения двух значений — равенство,
больше-меньше, неравенствo — всё это входит в следующую категорию. И
для описания всех возможных комбинаций у нас существует целых шесть
методов. Глубоко вдохнули и сделали последний рывок

(видео конспект)

https://drive.google.com/open?id=1v4yck3D6XqP_WF3fkRHGe9FC7vN24oGW Равенство


----------------------------------------------------------------

(Говорящая голова)

Вот мы разобрались с тем, что из себя представляет полиморфизм.
Звучит и правда гораздо страшнее, чем выходит на самом деле. До тех
пор пока у вас есть твердая уверенность в том, что вы можете изменить
любое поведение ваших объектов, и у вас есть знание того как это
сделать, никаких проблем с полиморфизмом у вас возникнуть не должно.
Изменение поведения также не является чем-то эзотерическим — вы просто
создаете метод, который вызывается в момент применения определенной
операции. Это либо некий этап в жизни объекта, как в случае
конструктора, или же взаимодействия с оператором, как в случае
большинства рассмотренных методов. Все встроенные типы данных
реализуют точно такие же методы, все библиотеки которые вы будете
устанавливать используют точно такую же систему. Таким образом вы
всегда можете самостоятельно написать тот функционал, который видите в
установленном модуле. Я всё же посоветую стремиться использовать чужой
код не выполняяя лишнюю работу, но просто для развлечения вполне можно
пытаться переписать чужие решения на свой лад. И не пытайтесь
запомнить сразу все возможные методы модификации поведения —
достаточно знать, что поведение можно изменить, А название метода вы
всегда сможете найти в интернете. Да и во многих случаях название
крайней очевидны, так что их можно просто угадать. А сейчас выполняем
домашнюю работу, награждаем себя чем-то вкусным, и идем баиньки,
потому что впереди у нас последний и самый запутанный урок из секции
объектно-ориентированного программирования. До встречи на следующем
занятии