#### Конкатенация {#concat}

Попытка сложить две строки приводит к их объединению
```python
>>> 'a' + 'b'
'ab'
>>> 'hello' + ' ' + 'world'
'hello world'
```

Если складывать строки с типами, не предусматривающими такую операцию, интерпретатор выдаст подобную ошибку
```python
>>> 'hello' + 10
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: must be str, not int
```

#### Повторение {#repeat}

Умножение строки на целое число приводит к появлению новой сроки, состоящей из n копий оригинала
```python
>>> '-' * 10
'----------'
>>> '-//-' * 20
'-//--//--//--//--//--//--//--//--//--//--//--//--//--//--//--//--//--//--//--//-'
>>>
```

В этой ситуации проявляется разница между целыми и дробными числами. Умножать строки можно только на целое число.

```python
>>> '!' * 2.0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't multiply sequence by non-int of type 'float'
```

#### Форматирование {#format-old}

Использование `%` выполняет подстановку данных в строку. Каждый фрагмент строки вида `%[модификаторы]буква_типа` будет заменен элементом из коллекции справа от оператора. Количество элементов в коллекции и количество подстановочных фрагментов обязательно должны совпадать.
```python
>>> 'hello %s' % ('world')
'hello world'
```

```python
>>> '%s %s' % ('hello', 'world')
'hello world'
```

Используя нужную букву типа, можно заставить python проверять корректность подставляемых элементов, выполнять их преобразование и выдавать ошибку, в случае неверных используемых данных.
```python
>>> '%d %d' % (10, 20)
'10 20'
```
```python
>>> '%d' % (1.1)
'1'
```
```python
>>> '%d' % ('hello')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: %d format: a number is required, not str
```

Модификаторы между буквой типа и символом процента определяют форматирование элемента в строке
```python
>>> '|%10s|%-10s|%10s|' % ('hello', 'world', 'very long phrase')
'|     hello|world     |very long phrase|'
```

> [Подробное описание модификаторов](https://docs.python.org/2/library/stdtypes.html#string-formatting)

#### Индексы {#index}

Строки - это коллекции отдельных символов. Характерной последовательностью большинства коллекций является возможность получения отдельного элемента коллекции, для чего используется уникальный идентификатор этого элемента. В зависимости от типа коллекции, правила формирования идентификаторов могут сильно отличаться. Например, упорядоченные коллекции используют числа, как идентификаторы. Каждый элемент имеет некоторое количество предшествующих элементов. Самый первый - 0(перед ним никого нет). Второй - 1(перед ним только первый элемент). Используя простую логику, можно прийти к выводу, что идентификатор каждого элемента равен его порядковому номеру минус один. Такие идентификаторы называют(ну, может только я их так называю) __индексами__.

Наиболее распространенным способом получения элемента коллекции можно считать оператор `[]`(пара квадратных скобок). Они пишутся после коллекции. Затем, внутри скобок прописывается идентификатор искомого элемента(так же это может быть переменная, содержащая идентификатор). Так как это оператор, можно использовать дополнительные пробелы(но не принято).

```python
>>> 'hello world'[0]
'h'
>>> 'hello world'  [  0  ]
'h'
>>> 'hello world'[1]
'e'
>>> 'hello world'[2]
'l'
>>> 'hello world'[3]
'l'
>>> 'hello world'[4]
'o'
>>> 'hello world'[5]
' '
>>> 'hello world'[6]
'w'
>>> i = 7
>>> k = 8
>>> 'hello world'[i]
'o'
>>> 'hello world'[k]
'r'
```
