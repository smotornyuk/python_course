# Лекция 9

(Говорящая голова)

Всем привет. Ну как, вы уже предвкушаете сегодняшнюю тему? Если вы уже
знакомы с планом обучения и знаете что сегодня мы наконец раскроем
наибольшую тайну нашего курса. На данный момент.  А именно - как
работают функции? Ну, мы уже знаем как они работают - мы их регулярно
использовали в своих экспериментах и даже пытались писать свои версии
того, что происходит внутри функции. Но как функцию создать и потом
повторно использовать? Это ведь нереально удобно — одной командой
заставлять выполняться множество операций.  Сегодня мы со всем этим
разберемся. Но прежде стоит описать тип функций.

Да возможно с этого и стоило начать. Функции - это всего лишь особый
тип данных. Даже не так, функции - это тип данных. Ничего особого в
них в общем-то и нет. Да их можно вызывать и они выполняют какое-то
действие. Но с другой стороны, и из списка можно извлекать отдельные
элементы по индексу, строки можно складывать, числа можно делить. Не
будем же мы считать каждый тип данных таким вот особенным. Да, у них
есть специфические свойства, но наличие каких-то отличительных
характеристик у каждого представители некого множество только лишь
подчеркивает что все представители в общем-то, не уникальны, а, скажем
так, как все.

Функции — этот тип данных. Они не являются коллекциями, а значит
применять к ним привычный нам категории пока что смысла не имеет. Но,
если функция это тип данных, значит она имеет какое-то значение. Что в
свою очередь приводит нас к факту того, что функцию можно присвоить в
переменную. Так что в будущем не стоит удивляться когда вы обнаружите,
что к функциям нет никакого особого отношения и более того их даже не
всегда вызывают. Если проводить аналогии, числа ведь тоже не всегда
складывают или вычитают, хоть это одна из основных задач . Таким
образом мы снова возвращаемся к тому что функции это весьма обыденнaя
вещь.  Начнем же писать функции направо и налево. Поехали

(видео конспект)

https://drive.google.com/open?id=1zZQij4JJYTiKdpd-Zkd7vA2CAKb9pfJU
Объявление ---


(Говорящая голова)

Ладно, тут я всё понял. А можно ли как-то использовать функции за
пределами стандартных вызовы. То есть, я конечно могу вызвать функцию
и она что-то выйдет на экран, но этого недостаточно! Я хочу чтобы
функции что-то считали и позволяли результаты своих вычислений
использовать в дальнейшем. Функции которые только выводят данные на
экран достаточно бесполезны, ведь у нас уже есть print.  А вот если вы
захотите написать функцию которая будет разделять список на две части
- первая половина элементов и вторая половина элементов - вам же нужно
будет сделать что-то такое, чтобы на месте функции оказывались эти две
половины, которые затем будут присвоены в переменную. Таким образом мы
пришли к тому, что называют возвращаемым значением функции.  И вот как
оно записывается

(видео конспект)

https://drive.google.com/open?id=1bjwYBMibH_vzCaKnnr4A8JT_BbJi4_79
возвращаемое значение ---


(Говорящая голова)

Теперь озвучим нечто, казалось бы вполне очевидное — функция свободно
работает с переменными. Вы можете описывать переменные внутри функции,
вы можете использовать переменные которые существуют снаружи функции,
одна функция может вызывать другую.  Вы же ещё не забыли, что функция
- это значение, а значит она хранится в переменной. И вызов функции,
на самом деле является поиском переменной, ссылающиеся на
функцию. Теперь то же самое, но короче. Функции свободно используют
любые переменные. Хорошее утверждение, но чуточку неверное. И всё же
сначала мы посмотрим видео, после которого возникнет вопрос — как это
"неверное", ведь всё прям кричит о том, что в реальности все так и
работает!

(видео конспект)

https://drive.google.com/open?id=1guiLuMPgtlw67X-fTnMZirFUpqAeMMN_
область видимости 1 ---

(Говорящая голова)

Так , надеюсь вы поверили в то что функция не видит проблем с
переменными. А теперь просто представим - мы создаем функцию которая
внутри себя создает кучу переменных, что-то в них записывает, удаляет
и так далее. Представьте сколько переменных вне функции могут быть
случайно изменены. Вы же не заглядывали внутри кода функции print и не
знаете, а создает ли oна внутри себя переменную A.  Если такая
переменная создается то у нас возникает риск перезаписать переменную
A, которую мы часто используем в своих тестах.  Для того чтобы
перестать об этом беспокоиться вам придется посмотреть следующий
фрагмент

(видео конспект)

https://drive.google.com/open?id=1-Sr7-jewzLDi9rj-DP8DZhkVo_magMuH
область видимости 2 ---

(Говорящая голова)

Если вы вообще не понимаете что только что произошло, сильно
переживать не стоит. Вот эти вот тонкости работы с переменными внутри
функций и снаружи, зачастую становится камнем преткновения для многих
начинающих программистов. И некоторые продолжают развиваться чтобы
спустя некоторое время всё же осознать насколько логично и просто
устроена работа с переменными, а кто-то сдаётся. Вы же относитесь к
первой группе, правда?  Я бы просто предпочел и ещё раз подытожить:
если внутри функции в переменную что-то присваивается, это переменная
считается локальной и Python будет считать что такая переменная
существует только внутри функции, благодаря чему никакого конфликта с
внешним миром не возникнет. Если же внутри функции в переменную ничего
не присваивается, Python попытается найти такую переменную с таким
именем вне вашей функции. После этого тезиса можно перейти к
следующей тонкости работы с функциями

(видео конспект)

https://drive.google.com/open?id=19TcpkuUIjDw0LTTMf6G-Qu-tWRVmWvCb
аргументы 1 ---

(Говорящая голова)

Ну тут всё элементарно, правда ведь?  Есть функция, вы ее вызываете,
пишите в скобочках парочку значений, функция срабатывает и что-то
делает с этим значениями. Просто внимательно следите за передачей
аргументов и тогда вы осознаете главную идею - то что вы пишете в
скобочках как-то транслируется внутри функции.  Внутренности функции
не знают точно о том как вы в неё передали аргумент, внутри функции
аргумент становится просто значением.  Как если бы вы создали
переменную в которую присвоили результат сложения 10 и 20. Переменная
была бы равна 30. Но переменная не знает, каким образом это число 30
было получено — то ли в результате сложения, то ли в результате
деления. Так и с функцией, она просто работает с теми значениями
которые вы написали в паре скобок. Проще подкрепить это практическим
разбором

(видео конспект)

https://drive.google.com/open?id=1N4clQXY1Lz88i9biWRaU2jZIp5CAFSuP
аргументы 2 ---

(Говорящая голова)

С аргументами становится очень весело. У них так много скрытых
особенностей. Попытайтесь вспомнить те функции которые уже вызывали -
print, например.  Ведь вы можете писать в его скобках одно, два, да и
в принципе любое количество значений — и она по-прежнему будут
работать. А с вашими функциями дела весьма печально — сколько
аргументов было объявлено в начале, столько должно быть предоставлено
каждый раз. Ну что, попробуем обойти это ограничение?

(видео конспект)

https://drive.google.com/open?id=1brhj5wGeV4-dTNmbZ6ad5K1ykhHNBn0v
аргументы 3 ---

(Говорящая голова)

Двигаемся дальше. Представляем что мы написали функцию с двадцатью
аргументами. Мне даже представлять такой страшно, но на практике
встречаются самые необычные ситуации. И вы просто забыли в каком
порядке эти аргументы следует. Я бы вообще забыл какие там аргументы
могут быть, но у вас память получше и вы знаете задачу каждого
аргумента. Единственное что вы путаете — это порядок следования. И нам
нужно как-то починить либо вас, либо функцию. Лучше остановимся на
функции и узнаем, как сигнализировать ей, что некий аргумент должен
восприниматься не относительно своей позиции, а как-то иначе -
например, по имени. И вот что нам предлагает Python

(видео конспект)

https://drive.google.com/open?id=1qmcnhAxA1gRQQOe92Ri4IBNbxY4WTRoH
аргументы 4 ---

(Говорящая голова)

Если вы до сих пор считаете сегодняшнюю тему понятной, то ставьте
видео на паузу и выполняйте задачу — написать собственную реализацию
всех функций с которыми мы столкнулись до сих пор. Включая методы
строк и списков. Последнее, кстати, не так уж и сложно, если учесть,
что на занятиях мы разбирали как приблизительно эти методы работают. И
даже писали свои реализации с помощью циклов. Осталось только
завернуть наш код в определение функции. А я параллельно буду делать
тоже самое. Но только у меня выдержки поменьше, так что я ограничусь
буквально парой функцией. Начинаем, наперегонки?

(видео конспект)

https://drive.google.com/open?id=1PCKrf1eGCJp9pyvJmTEXL-qa4Z5hYhoc
собственные функции 1 ---

(Говорящая голова)

А ведь и правда удобно, с этим трюком с передачей списка в
аргумент. Мы можем заставлять функцию обрабатывать неограниченные
объемы данных, пока хватает ресурсов вашего компьютера. На чём бы
попрактиковаться дальше? Раз Python считают языком математическим,
давайте-ка складывать и умножать. А вам новый квест — если вы всё же
пропускаете меня вперёд с реализацией функций, то после просмотра
фрагмента напишите свою версию реализации, только чур чтобы она
отличалась от моей. Причём, как можно сильней.

(видео конспект)

https://drive.google.com/open?id=1P-QR1S_7BnAXOkg-P2IimIcpP-ageTSq
собственные функции 2 ---

(Говорящая голова)

Ну и чтобы не обижать методы , давайте-ка реализуем что-то из них. По
всем критериям методы — это самые обычные функции. Да они находятся в
каких-то значениях, они специализируются на конкретных типах, Но это
по-прежнему функции, которые принимают аргументы и временами
возвращают значение. Между прочим, давным-давно все методы работы со
строками в питоне были реальными отдельными функциями, Но со временем
было решено что это неудобно — зачем иметь так много функций
разбросанных по коду если их всех можно собрать внутри строк. С тех
пор методы вроде title или replace существует не в виде
самостоятельных функций, а размещаются внутри строк. А мы сейчас
попытаемся заглянуть в прошлое создать одну из давно ушедших функций

(видео конспект)

https://drive.google.com/open?id=1bAwUXYggmLixxRJarEpvJU1GyZWIT42l
собственные функции 3 ---

(Говорящая голова)

Знаете, некоторые решения в программировании временами начинают
казаться кощунственными. Только представьте себе психа, который захочет
создать функцию внутри функции . А ещё хуже если это родительская
функция тоже находится внутри третьей функции. Мне неуютно становится
от самой идеи ... Хотя нет, сейчас я нагло вру. А если быть честным то
каждому из вас придется не раз нечто подобное сделать. Более того это
весьма распространенный шаблон проектирования, который делает создание
функций более гибким. Попробуем и сами


(видео конспект)

https://drive.google.com/open?id=11XfJQVW2nEP3eMDZLtUTelMGKZU8o6CU
область видимости 3 ---

(Говорящая голова)

Представляю сейчас в вашей удивлённые глаза и немой вопрос — кому
вообще это может пригодиться. А для ответа на ваш вопрос придется
посмотреть следующий фрагмент. И тут мы снова возвращаемся к
переменным которые существуют внутри и вне функции . Самое время
вернуться на пару шагов назад и пересмотреть соответствующий фрагмент
ещё раз. Понимание происходящего крайне критично в следующем видео

(видео конспект)

https://drive.google.com/open?id=17NnVzUu9PDu0zyvEM5j1ibrEH0n_d272
область видимости 4 ---

(Говорящая голова)

Вот так вот. Думаю последний фрагмент заслуживает аплодисментов, Мы
ещё не встречали более запутанной темы, чем эти области видимости. Но
они весьма удобные и практичные. Также, как только на вас снизойдет
понимание происходящего, вам останется только удивляться, как это
можно было не понимать с самого начала. Из хороших сторон стоит
заметить, что в Python, этот приём используется не так часто, как,
например, в JavaScript. Хотя я даже сомневаюсь, а правда ли это
хорошая сторона. Мне, например очень нравится создавать функции внутри
функций — чувствуется некая таинственность и собственнoe могущество. А
вам ещё предстоит определиться. Я бы посоветовал не спешить с выбором
и не относиться категоричнo к чему-либо.  Считать что-то бесполезным
просто потому что это не нужно вам — это, как минимум, не очень
корректно. Влюбляться в новую технологию программирования и пытаться
использовать ee абсолютно везде - тоже не самая лучшая идея, просто
потому что для каждой задачи существует свое наилучшее решение. И,
соответственно, одно и тоже решение не может быть наилучшим всегда -
иначе других просто не существовало бы. Ну, философия это не мой
конёк, так что я пожалуй ретируюсь. Удачи в тестах и до следующей
встречи