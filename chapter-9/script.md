# Лекция 9

(Говорящая голова)

Всем привет. Ну как, вы уже предвкушаю эти сегодняшнюю тему. Вы же
знакомлю вылетит планом обучения и знаете что сегодня мы наконец
раскроем наибольшую тайну нашего курса. на данный момент.  А именно,
как работают функции? Ну мы уже знаем как они работают - мы их
регулярно использовали в своих экспериментах и даже пытались писать
свои версии того что происходит внутри функции. Но как функцию создать
и потом повторно использовать? Это ведь не реально удобно — одной
командой заставлять выполняться множество операций.  Сегодня мы совсем
этим разберемся, Но прежде стоит описать тип функций.

Да возможно с этого И стоило начать. Функции Это всего лишь особый тип
данных. Даже не так, функции Это тип данных. Ничего особого в них в
общем-то и нет. Да их можно вызывать и они выполняют какое-то
действие. Но с другой стороны, и списком можно извлекать отдельные
элементы по индексу, строки можно складывать, числа можно делить. Не
будем же мы считать каждый тип данных таким вот особенным. Да у них
есть специфические свойства , но наличие каких-то отличительных
характеристик у каждого представители никого множество только лишь
подчеркивает что все представители в общем-то, не Уникальны, а, скажем
так, как все.

Функции — этот тип данных. Они не являются коллекциями, а значит
применять к ним привычный нам категории пока что Смысла не имеет. Но ,
если функция Это тип данных, Значит она имеет какое-то значение. Что с
выучить приводит нас к факту того, что функцию можно присвоить в
переменную. Так что в будущем не стоит удивляться Когда вы обнаружите,
что к функциям нет никакого особого отношения и более того их даже не
всегда вызывают. Если проводить аналогии, числа ведь тоже не всегда
складывают или вычитают, хоть это одна из основных задач . Таким
образом мы снова возвращаемся к тому что функции это весьма обыденнaя
вещь.  Начнем же писать функции направо и налево . Поехали

(видео конспект)

https://drive.google.com/open?id=1zZQij4JJYTiKdpd-Zkd7vA2CAKb9pfJU
Объявление ---


(Говорящая голова)

Ладно, тут я всё понял. А можно ли как-то использовать функции за
пределами стандартных вызовы. То есть, Я конечно могу вызвать функцию
и она что-то выйдет на экран, но этого недостаточно ! Я хочу чтобы
функции что-то с читали и позволяли результаты своих вычислений
использовать в дальнейшем. Функции которые только бывают на экран
достаточно бесполезны, ведь у нас уже есть print.  А вот если вы
захотите написать функцию которая будет разделять список на две части
- первая половина элементов и вторая половина элементов - вам же нужно
будет сделать что-то такое, чтобы на месте функции оказывались эти две
половины, которые затем будут присвоены в переменную. Таким образом мы
пришли к тому что называют возвращаемым значением функции.  И Вот как
оно записывается

(видео конспект)

https://drive.google.com/open?id=1bjwYBMibH_vzCaKnnr4A8JT_BbJi4_79
возвращаемое значение ---


(Говорящая голова)

Теперь озвучим ничто, Казалось бы вполне очевидной — функция свободно
работает с переменными. Вы можете описывать переменные внутри функции,
Вы можете использовать переменные которые существуют снаружи функции,
одна Функция может вызывать другую.  Вы же ещё не забыли, что функция
- это значение, а значит она хранится в переменной. И вызов функции,
на самом деле является поиском переменной, ссылающиеся на
функцию. Тоже самое, но короче. Функции свободно используют любые
перемены. Хорошее утверждение, но чуточку неверное. И всё же Сначала
мы посмотрим видео, после которого возникнет вопрос — как это Неверная
, ведь всё прям кричит о том, что да так и есть!

(видео конспект)

https://drive.google.com/open?id=1guiLuMPgtlw67X-fTnMZirFUpqAeMMN_
область видимости 1 ---

(Говорящая голова)

Так , надеюсь вы поверили в то что функция не видит проблем с
переменными. А теперь просто представим - мы создаем функцию которая
внутри себя создает кучу переменных , что-то в них записывает, удаляет
и так далее. Представьте сколько переменных вне функции могут быть
случайно изменены. Вы же не заглядывали внутри кода функции print и не
знаете, а создает Ли oна внутри себя переменную A.  Есть ли такая
переменная создается то у нас возникает риск, не перезаписаться ли
переменная A которую мы часто используем в своих текстах.  Для того
чтобы перестать об этом беспокоиться вам придется посмотреть следующий
фрагмент

(видео конспект)

https://drive.google.com/open?id=1-Sr7-jewzLDi9rj-DP8DZhkVo_magMuH
область видимости 2 ---

(Говорящая голова)

Если вы вообще не понимаете что только что произошло, сильно
переживать не стоит. Вот это вот тонкости работы с переменными внутри
функций и снаружи, зачастую становится камнем преткновения для многих
начинающих программистов. И некоторые продолжают развиваться чтобы
спустя некоторое время всё же осознать насколько логично и просто
устроена работа с переменными , а кто-то сдаётся. Вы же относитесь к
первой группе, правда?  Я бы просто предпочел и ещё раз подытожить:
если внутри функции в переменную что-то присваивается, это переменная
считается локальной и Python будет считать что такая переменная
существует только внутри функции, благодаря чему никакого конфликта с
внешним миром не возникнет.  Если же внутри функции в переменную
ничего не присваивается, Python попытается найти такую переменную с
таким именем вне вашей функции.  После этого тезиса Можно перейти к
следующей тонкости работы с функциями

(видео конспект)

https://drive.google.com/open?id=19TcpkuUIjDw0LTTMf6G-Qu-tWRVmWvCb
аргументы 1 ---

(Говорящая голова)

Ну тут всё Элементарно, правда ведь?  Есть функция, вы ее вызываете,
Пишите в скобочках парочку значений, функция срабатывает и что-то
делает с этим значениями. Просто внимательно следите за передача
аргументов. Осознаете главную идею - то что вы пишете в скобочках
как-то транслируется внутри функции.  Внутренности функции не знаю
точно о том как вы в неё передали аргумент, внутри функции аргумент
становится просто значением.  Как если бы вы создали переменную в
которую присвоили результат сложения 10 и 20. Переменная была бы равна
30. Но переменная не знает Каким образом это число 30 было получено —
то ли в результате сложения, то ли в результате деления. Так и с
функцией, она просто работает с теми значениями которые вы написали в
паре скобок. Проще подкрепить это практическим разбором

(видео конспект)

https://drive.google.com/open?id=1N4clQXY1Lz88i9biWRaU2jZIp5CAFSuP
аргументы 2 ---

(Говорящая голова)

С аргументами становится очень весело. У них так много скрытых
особенностей. Если вы попытаетесь вспомнить те функции которые уже
вызывали, print, например.  Ведь вы можете писать в его скобках одно,
Два, да и в принципе любое количество значений — и он по-прежнему
будут работать. А с вашими функциями дела Весьма печально — сколько
аргументов было объявлено в начале, столько должно быть предоставлено
каждый раз. Ну что, попробуем обойти это ограничение?

(видео конспект)

https://drive.google.com/open?id=1brhj5wGeV4-dTNmbZ6ad5K1ykhHNBn0v
аргументы 3 ---

(Говорящая голова)

Двигаемся дальше. Представляем что мы написали функцию с двадцатью
аргументами. Мне даже представлять такой страшно, Но на практике
встречаются самые необычные ситуации. И вы просто забыли в каком
порядке эти аргументы следует. Я бы вообще забыл какие там аргументы
могут быть, но у вас память получше и вы знаете задачу каждого
аргумента. Единственное что вы путаете — это порядок следования. И нам
нужно как-то починить либо вас, либо функцию. Лучше остановимся на
функции — как сигнализировать функцию что некий аргумент должен
восприниматься не относительно своей позиции , а как-то иначе,
например, по имени. И вот что нам предлагает пальтом

(видео конспект)

https://drive.google.com/open?id=1qmcnhAxA1gRQQOe92Ri4IBNbxY4WTRoH
аргументы 4 ---

(Говорящая голова)

Если вы до сих пор считаете сегодняшнюю тему понятной, то ставьте
видео на паузу и выполняйте задачу — написать собственную реализацию
всех функций с которыми мы столкнулись до сих пор. Включая методы
строк и списков. Последняя, кстати, не так уж и сложно , Если учесть
что на занятиях мы разбирали как приблизительно эти методы работает. И
даже писали свои реализации с помощью циклов. Осталось только
завернуть Наш код в определение функции. А я параллельно буду делать
тоже самое. Но только у меня выдержки поменьше, Так что я ограничусь
буквально парой функцией. Начинаем, наперегонки?

(видео конспект)

https://drive.google.com/open?id=1PCKrf1eGCJp9pyvJmTEXL-qa4Z5hYhoc
собственные функции 1 ---

(Говорящая голова)

А ведь и Правда удобно, с этим трюком с передачей списка в
аргумент. Мы можем заставлять функцию обрабатывать неограниченные
объемы данных, пока хватает ресурсов вашего компьютера. На чём бы
попрактиковаться дальше? Раз Python считают языком математическим,
давайте-ка складывать и умножать. А вам новый квест — Если вы всё же
пропускаете меня вперёд с реализацией функций, то после просмотра
фрагмента напишите свою версию реализации, только чур чтобы она
отличалась от моей. причём, Как можно сильней.

(видео конспект)

https://drive.google.com/open?id=1P-QR1S_7BnAXOkg-P2IimIcpP-ageTSq
собственные функции 2 ---

(Говорящая голова)

Ну и чтобы не обижать методы , давайте-ка реализуем что-то из них. По
всем критериям методы — это самые обычные функции. Да они находятся в
каких-то значениях, они специализируются на конкретных типах, Но это
по-прежнему функции, которые принимают Аргументы и временами
возвращают значение. Между прочим, давным-давно все методы работы со
строками в питоне были реальными отдельными функциями, Но со временем
Было решено что это неудобно — Зачем иметь так много функций
разбросанных по коду если их всех можно собрать внутри строк. С тех
пор методы вроде title или replace не существует в виде
самостоятельных функций, а размещается внутри строк. А мы сейчас
попытаемся заглянуть в прошлое создать одну из давно ушедших функций

(видео конспект)

https://drive.google.com/open?id=1bAwUXYggmLixxRJarEpvJU1GyZWIT42l
собственные функции 3 ---

(Говорящая голова)

Знаете, некоторые решения программирование временами начинает казаться
кощунственным. Только представьте себе психо, который захочет создать
функцию внутри функции . А ещё хуже если это родительская функция тоже
находится внутри третьей функции. Мне неуютно становится от самой идеи
... Хотя нет, сейчас я нагло вру. А если быть честным то каждому из
вас придется не раз нечто подобное сделать. Более того это весьма
распространенный шаблон проектирования, который делает создание
функций более гибким. Попробуй и сами


(видео конспект)

https://drive.google.com/open?id=11XfJQVW2nEP3eMDZLtUTelMGKZU8o6CU
область видимости 3 ---

(Говорящая голова)

Представляю сейчас в вашей удивлённые глаза и немой вопрос — кому
вообще Это может пригодиться. А для ответа на ваш вопрос придется
посмотреть следующий фрагмент. И тут мы снова возвращаемся к
переменным которые существуют Внутри и вне функции . Самое время
вернуться на пару шагов назад и посмотреть соответствующий фрагмент
ещё раз. Понимание происходящего край некритично в следующем видео

(видео конспект)

https://drive.google.com/open?id=17NnVzUu9PDu0zyvEM5j1ibrEH0n_d272
область видимости 4 ---

(Говорящая голова)

Вот так вот. Думаю последний фрагмент заслуживает аплодисментов, Мы
ещё не встречали более запутанной Темой чем эти области видимости. Но
они весьма удобные и практичные. Также, как только на вас снизойдет
понимание происходящего, вам Останется только удивляться, как это
можно было не понимать с самого начала. Из хороших сторон стоит
заметить, что в Python, этот приём используется не так часто, как,
например, в JavaScript. Хотя я даже сомневаюсь, А правда ли это
хорошая сторона. Мне, например очень нравится создавать функции внутри
функций — чувствуется некая таинственность и собственнoe могущество. А
вам Ещё предстоит определиться. Я бы посоветовал не спешить с выбором
и не относиться категоричнo к чему-либо.  Считать что-то бесполезным
просто потому что она не нужна Вам — это, как минимум, не очень
корректно. Влюбляться в Новую технологию программирования и пытаться
использовать ee абсолютно везде - тоже не самая лучшая идея , просто
потому что для каждой задачи существует свое наилучшее решение. И,
соответственно, одно и тоже решение не может быть наилучшим всегда -
иначе других просто не существовало бы. Ну, философия это не мой
конёк, Так что я пожалуй ретируюсь. Удачи в тестах и до следующей
встречи