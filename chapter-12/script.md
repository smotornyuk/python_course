# Лекция 12

(Говорящая голова)

И снова здравствуйте. Сегодня мы продолжим изучать объекты, но слегка
с другого ракурса. Мы познакомимся с некоторыми объектами которые
нельзя считать базовыми, но которые, тем не менее, включены в питон по
умолчанию. А для этого нам придется изучить второй способ организации
кода - модули. В разных источниках модули называют библиотеками кода,
пакетами , плагинами, а может даже ещё как-то. В питоне все эти
определения относятся к одной и той же сущности — к самостоятельному
файлу, в котором прописан код. Любой такой файл может быть подключен к
вашей программе и, как следствие, вы можете использовать весь
функционал созданный в этом файле. Модули открывают бесконечные
возможности для повторного использования кода, обменa решениями и
распространения своих наработок. На практике вы не раз столкнетесь с
ситуацией, когда ваша задача уже была кем-то выполнена и единственное,
что остается - это найти, скачать и установить готовое решение. Так
что работать с модулями очень важно. Кроме того они позволяют вам
гораздо опрятней организовать свой код, разбив методы не только по
классам, но и распределив их по соответствующим файлом. Давайте
взглянем на всё это в реальной жизни.

(видео конспект)


https://drive.google.com/open?id=1oIGYlAfjSVm-HSiT2FhgZdqFvtmnuRpV
импорт

-----

(Говорящая голова)

Сама по себе инструкция импорта выглядит достаточно просто. У вас есть
какой-то файл и вы создаете объект в котором всё из этого файла
копируется — как-то так можно описать работу инструкции импорт. Но
импортировать вообще всё может оказаться немного лишним. Вполне
возможно что в стороннем файле определены сотнеи или даже тысячи
функций, а из них нам нужны только две или три.  Или ещё хуже — вдруг
у вас в текущем коде уже есть переменная чье название совпадает с
именем в библиотеки.  С одной стороны, эта переменная вам очень важна
и вы не хотели бы ее затереть библиотекой. С другой стороны,
библиотека вам нужна также, и ее нужно как-то импортировать. Было бы
очень хорошо если бы мы могли импортировать библиотеку под другим
именем. Давайте же посмотрим на расширенный синтаксис импорта

(видео конспект)

https://drive.google.com/open?id=1LAn_95jLFPkTpR5DZztBtyOSsGjRDwft
расширеный импорт

-----

(Говорящая голова)

Вот вроде мы и решили проблему с аккуратным импортом. И, казалось бы,
что может пойти не так? Дело в масштабе — хоть на первый взгляд
разделение кода по файлам и решает проблему размеров файлов, но в
реальных проектах разнообразие задач таково, что у вас легко может
оказаться сотня, а то и 1000 файлов в одной папке. Разумеется, с этим
работать не очень удобно, и вместо простого разбиения по файлам,
хочется разделять уже файлы по папкам. Такая возможность присутствует
в питоне и она не требует каких-то значительных усилий. Есть всего
одно правило которое нужно соблюдать, но, поверьте мне, оно достаточно
простое и у вас не должно возникнуть с ним проблем. Вот как мы с этим
разберемся

(видео конспект)


https://drive.google.com/open?id=12xr-0HYRdTqwMjMkVHbFfFNlf_W2Ekv0
импорт директорий


-----

(Говорящая голова)

И как обычно — с одной стороны стало лучше и у нас появилось больше
возможностей. С другой стороны, только представьте вот эти длиннющие
пути импорта вложенных директорий. Ладно ещё импорт, так мне же потом
эти элементы ещё использовать нужно везде с длинными именами. Так дела
не пойдут. Нужно всё-таки придумать какой-то хитрый способ изменения
имени наших библиотек. Хотя, зачем придумывать, если вы его уже
знаете?

(видео конспект)

https://drive.google.com/open?id=139Q1SvRYsYEv3vqoGcWy7Kw5CiGo8I2W
импорс с переименовыванием

-----

(Говорящая голова)

Как-то всё слишком хорошо чтобы быть правдой. Всё, перехожу на темную
сторону и рассказываю вам о подводных камнях. В принципе, их немного,
но они могут вам не слабо попортить жизнь. Выделить стоит два
камня. Первый из них — это циклический импорт. Представьте что вы
импортируйте библиотеку X, которая в свою очередь импортирует
библиотеку Y, которая снова импортирует X. Как тут не возникнуть
ошибке — чтобы загрузилась первая библиотека, должна загрузиться
вторая, но она не может загрузиться пока не загрузится первая.  И
другая проблема - относительный импорт. Если у вас многоуровневая
библиотека, на каждом уровне которой определён модуль Икс, как не
запутаться и понять, какой из X мы импортируем в данный момент.
Настало время решать проблемы

(видео конспект)

https://drive.google.com/open?id=1dnIlPIx5wGUcdjTmhIx624hzvlyBSI1j
проблемы импорта (если слишком долго, можно разрезать на два
фрагмента: первый до 3:18, второй после 3:20) -----

(Говорящая голова)

Пожалуй, это всё что нужно знать об импорте на данный
момент. Импортируйте теперь всё подряд в свое удовольствие.  А вот
откуда брать библиотеки? Писать всё самостоятельно, чтобы потом
импортировать уже и не хочется. Нужны чужие готовые решения. Приятная
сторона ситуации заключается в том, что куча готовых решений уже
включена в стандартный набор библиотек поставляемых вместе с
Python. Неприятное — вам не помешает прочитать документацию этих
библиотек. Но я всегда питал слабость к объяснением, потому, так уж и
быть, проведу для вас небольшую экскурсию. Начнем мы с самой нужной
вещи для каждого программиста — генератора случайных чисел.

(видео конспект)


https://drive.google.com/open?id=1xycSw4nL7QbQZa3D9CCuuQoGhNbJHBqz
random


-----

(Говорящая голова)

С помощью библиотеки Random можно значительно улучшить вашу игру с
угадыванием числа из предыдущих уроков. И даже сделать что-то более
сложное, вроде викторины, в которой вам придется ответить на 10
случайных вопросов из миллиона возможных. Также случайные числа можно
использовать для шифрования, награждения ваших пользователей
случайными подарками, выбора победителя на конкурсе и множествa других
увлекательных задач. О чём бы рассказать ещё? Этих встроенных
библиотек так много... О, расскажу про простую библиотеку с функциями,
которые мы так часто реализовывали.

(видео конспект)

https://drive.google.com/open?id=1i_tP8I0R6QcNXR-xKhkJ8834A2OobFL5
operator

-----

(Говорящая голова)

Раз уж я заговорил о встроенных библиотеках, то нужно рассказать вам о
чём-то таком, что позволит мне добавить в домашнее задание нечто очень
сложное. В таком случае стоит поговорить о сериализации данных. Язык
можно сломать об это слово, но описывает оно очень полезную
штуковину. Сериализация - это скорее процесс, причём, процесс
обратимый. Обратное направление называется десериализацией. Смысл
этого процесса заключается в преобразовании некой структуры данных в
текст, с целью последующего преобразования обратно в структуру
данных. Наиболее очевидный пример использования сериализации —
сохранение данных в файл. Представьте что у вас есть массив строк. Вы
можете записать каждую строку на отдельной линии в файле и в будущем
считать этот файл восстановив список отдельных элементов. А теперь
представим, что в оригинальном списке, одна из строк содержалось
символ переноса. Благодаря этому, при записи в файл у вас образуется
на одну линию больше. И при считывании будет сложно понять, какая из
строк только притворяется отдельным элементом. Задачи сериализации —
обойти эту проблему. Вот одна из библиотек которая может нам в этом
деле помочь

(видео конспект)

https://drive.google.com/open?id=1Oe3nDQC2wSsL8y1mMcfyEmilM_22lqcd
csv

-----

(Говорящая голова)

Поработав некоторое время с CSV форматом, вы обнаруживаете что он
весьма хорошо справляется с текстовыми данными. Но лишь до тех пор,
пока данные можно представить в виде двумерного массива строк. Как
только вам нужно выразить словарь, или массив имеет больше уровней
вложенности, или вы работаете с числами и булевыми значениями, CSV
формат становится недостаточно выразительным. В такой ситуации нам
нужно копнуть глубже и обнаружить вторую библиотеку для сериализации
данных

(видео конспект)

https://drive.google.com/open?id=19RRq0XHQZSXvJJ8Jqnn5m8ixXb_Tu4m_
json

-----

(Говорящая голова)

Ура, очередной барьер, отделяющий вас от блистательной карьеры
программиста, сломлен. Огромное количество модулей мы не затронули. В
одной только стандартной библиотекe их больше сотни, не говоря уже о
тех модулях, которые вы можете скачать из интернета. Но нет смысла
заучивать всё подряд — вместо этого сконцентрируйтесь на том что
кажется полезным именно в вашей сфере деятельности. И каждый раз когда
у вас появляется новое задание, попытайтесь поискать библиотеку
которая уже делает то, что вам требуется. Если даже вы не найдете
готового решения, вполне вероятно вам попадутся необходимые
инструменты, с помощью которых добиться успеха гораздо проще. И
конечно же пытайтесь писать свои собственные библиотеки. Участие в
разработке общедоступного кода — это один из наиболее надежных и
эффективных способов заработать себе немного славы и, заодно,
попрактиковаться на реальных задачах. На этой ноте я с вами прощаюсь
иду готовить материал для следующего занятия. До скорой встречи
