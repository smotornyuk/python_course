# Лекция 7

(Говорящая голова)

Всем привет, давно уже не виделись. Я подготовил на сегодня нечто
совершенно новое, как компенсацию за простой предыдущий урок. Сегодня
мы столкнемся с новой структурой данных которую в питоне принято
называть словарем. Хорошее название хотя бы потому что оно достаточно
точно отражает задачи этой структуры — описывать коллекцию связанных
данных. Представим самый обычный словарь — это книга в которой есть
множество терминов-слов и их перевод. Причём оригинальные слова,
которые вы собираетесь переводить, уникальны.  Каждое из них
присутствуют в единственном экземпляре. А вот переводов для каждого
слова может быть несколько. Или, например, толковый словарь. К каждому
термину у вас есть достаточно объемное определение, но на один термин
имеем ровно одно определение. Кстати, в других языках подобные словарям
структуры временами называют картами, отражениями или даже
массивами. Последнее определение требует уточнения — правильнее будет
сказать ассоциативными массивами. То есть, массив ассоциаций — с неким
термином ассоциируется некое определение. При желании можно заметить
связь также в термине отражение и карта с тем что мы сказали о
словарях в питоне. Отражение выражает особенности словаря отражать
смысл термина некоторым определением. Карта это схематическое
отображение связи между неким ключом и связанным с ним значением. В
общем как это не назвать смысл  остается прежним — словарь это
коллекция пар определяющих две стороны одной сущности.  Начнем же
сегодняшнюю тему

(видео конспект)

https://drive.google.com/open?id=1UgT0kT5FATxjPbrbzB0KL7fprz7Ryn-s
литералы ---


(Говорящая голова)

Словари- это коллекция, А значит их можно категоризировать. Словарь
относится к неоднородным коллекциям, вследствие чего в одном словаре
могут содержаться значение самого разного типа. Подобное поведение мы
наблюдали в списках. Кроме того, словари — это неупорядоченные
коллекции. До сих пор мы не затрагивали категорию упорядоченности,
потому что обе коллекция которые мы видели были упорядочены. Есть ли
вы переставить элементы местами в строке или в списке вы получите
совершенно другой экземпляр. Так что порядок элементов в строках и в
списках очень важен. В случае словаря важно лишь наличие связей между
ключом и значением. В каком порядке будут следовать ключи никого не
интересует. И, наконец, изменяемость. Словари изменяемы, что влечет за
собой наличие в них всех проблем которые мы обнаружили для списков.

(видео конспект)

https://drive.google.com/open?id=14f_6rBrhVzyYgYS3G8EmD00ahy1YqtXF
Модификации ---


(Говорящая голова)

А как словари взаимодействуют с другими типами данных? В принципе,
достаточно предсказуемо, а именно — вообще не взаимодействуют, с
небольшими исключениями. Да и действительно, как можно сложить некий
толковый словарь и цифру 10? Или как вы собираетесь умножать словари
если каждый ключ в словаре должен быть уникальным. Единственный формат
взаимодействия, который доступен в словарях, это преобразование из
одного типа данных в другой. Если быть более точным, словарь может
быть преобразован в другой тип данных если этот тип также относится к
коллекциям.  И наоборот, коллекция может быть преобразована в
словарь. Правда, в обоих этих случаях есть несколько дополнительных
требований

(видео конспект)

https://drive.google.com/open?id=15Cax-YXtZlyIIwPYiUjhHyHWP5c7aGAn
Взаимодействие ---

(Говорящая голова)

Удивительный факт — у словарей также имеются методы. Ладно, ничего
удивительного в этом нет - в будущем мы увидим, что у каждого типа
данных есть методы. Так что вопросом будет скорее — какие именно
методы есть у словаря . Начнём с чего-то слегка знакомого нам.
Словарь — это коллекция, А значит у него должны быть некоторые методы
специфичные для коллекций. Словари не упорядочен, так что сортировка
для него смысла не имеет. Но словарь изменяем и он содержит множество
элементов, а значит есть смысл эти элементы модифицировать. Начнём с
этой базовой операции

(видео конспект)

https://drive.google.com/open?id=1C5pym_3jf4YGcZZvHtIz-9Mtuy_KXi6G
Методы ---

(Говорящая голова)

Если вы экспериментируйте по мере продвижения в уроке, то вы наверняка
уже не раз получали ошибку при попытке извлечь несуществующий элемент
из словаря. Да уж, со списками было гораздо проще. Если знаешь длину
списка, то можешь с уверенностью сказать есть ли в нём элементы
индексом 10 или нет. В случае словаря ключи слабо связаны с цифрами
поэтому понять есть ли там определенный ключ или нет достаточно
сложно. Можно конечно взять и создать новый элемент в словаре чтобы
быть уверенным что он там есть, но вдруг вам не хочется случайно
затереть существующие данные. И вот как эту проблему можно решить

(видео конспект)

https://drive.google.com/open?id=1W1-en-E-h2diyl_WV8xiwMI90cEK3AeT
Методы 2 ---

(Говорящая голова)

OK ну, это уже что-то. Но серьёзно, этого не хватит для написания
реального кода. Вы можете не получить ошибку, пытаясь извлечь ключ,
которого в словаре нет. Благодаря этому, ваша программа проживёт
немного дольше. А вот как извлечь всё что есть в словаре, если вы не
знаете какие ключи в нём определены? Перебирать все возможные
комбинации слов — это занятие крайне неблагодарное. Именно поэтому для
вас в словаре присутствует целых 3 способа легко извлечь всё
содержимое словаря за один подход.  Давайте на них взглянем

(видео конспект)

https://drive.google.com/open?id=1-uu58TWl9Y256XF6BU2cZRjZciKwc3QU
Методы 3 ---

(Говорящая голова)

И осталась последняя категория методов — методы для извлечения и
удаления отдельных элементов. Элементы из словаря можно удалять с
помощью базовой инструкции del. Но для этого вам нужно знать какие
элементы в словаре есть. То есть вам придется сначала извлечь список
всех элементов затем пройтись в цикле по этому списку и на каждой
итерации произвести удаление. Но если нам перед удалением элемент
нужно ещё как-то обработать то приходится писать слишком много
кода. Для простоты словари украли идею из списков. В них есть
специальный метод который позволяет извлечь одно-единственное значение
словаря , присвоить это значение в переменную, а потом удалить его из
коллекции. Более того, таких методов даже 2 . И вот как они работают

(видео конспект)

https://drive.google.com/open?id=13ZOfXnWJE-bQRHOaGwHhCYCD2BCtHGtl
Методы 4 ---

(Говорящая голова)

Мы уже весьма далеко зашли, потому я предлагаю вам реализовать еще
парочку классических алгоритмов и структур данных, но в слегка
упрощённой форме. У нас есть словари, которые крайне удобны для
описание сложных данных содержащих множество различных свойств. Ведь
каждый ключ словаря может может восприниматься как отдельный параметр
элемента, в то время как весь словарь будет самим элементом. Если
говорить на человеческом, представим что у нас есть словарь ,
хранящейся в переменной человек. Внутри этого словаря есть ключи: цвет
глаз, рост, возраст, имя. И каждому такому ключу в соответствие идёт
какое-то значение, описывающая характеристику конкретного человека.
Или у вас может быть словарь описывающий число — в этом словаре будет
два ключа: абсолютное значение числа и его знак, который определяет
положительно наши число или отрицательно. Но мы пойдем сложным путем и
реализуем что-то новое, а именно - стек. Это что-то вроде списка, но
без доступа к любому элементу коллекции в любой момент времени, а с
возможностью получить только самый последний элемент коллекции. Чтобы
извлечь второй элемент вам придётся удалить первый. Чтобы извлечь
самый последний элемент, вам придётся удалить все элементы стоящие
перед ним. Если уточнить терминологию, то самым первым элементом стека
считается тот элемент, который был добавлен в него в последнюю
очередь. Таким образом, стек похож на стопку книг. Перейдем к
реализации

(видео конспект)

https://drive.google.com/open?id=1Euc5SEYcqcpbgwVdDpG9IVggUgTeZ5NM
Стек ---

(Говорящая голова)

И ещё одна структура, до неприличия похожая на стек, которая
называется очередью. Весьма банальное название, не спорю. Но онo
хорошо подчеркивает отличия такой коллекции от стека - самым первым
элементом в очереди считается тот, который в эту очередь раньше всех
попал. Последним элементом очереди считается тот который попал в неё в
последнюю очередь, как бы жутко это не звучало. Таким образом чтобы
последний элемент был обработан, нам придётся извлечь из очереди все
элементы появившиеся в ней раньше. Это достаточно справедливо и
реализуется почти как в предыдущем видео. Как насчёт того, чтобы не
смотреть следующий фрагмент а попытаться написать код подходящие под
это описание самостоятельно. Когда закончите — сравните с моей версией


(видео конспект)

https://drive.google.com/open?id=1NBr6dnOkzH40AIv0sWxs38ymOkqLnNbE
Очередь ---

(Говорящая голова)

Наверное самый душещипательный момент в жизни каждого программиста,
это та секунда когда его программа начала с программистом общаться. Не
просто выводить текст на экран, а также слушать что вы скажете в
ответ.  Ладно-ладно возможно слушать это слишком сильное слово ... Как
минимум, программа должна позволять вам ввести какую-то фразу, считать
эту фразу и ответить на неё что-то.  Такая стратегия бывает крайне
удобной при построении каких-либо меню. У вас есть десяток разных
вариантов ответа, вы вводите с помощью клавиатуры то, что желаете
увидеть и получаете результат. А в более сложной реализации, вполне
можно представить чат в котором всё что вы водите будет передано
вашему собеседнику с помощью вашей же программы.

Давайте попробуем склонить нашу программу к общению...

(видео конспект)

https://drive.google.com/open?id=1jpl1W8kXXdrlP6MyrU2zbSGx-z4aW1ES
Меню ---

(Говорящая голова)

Ну и куда без игр. Наверное, больше половины программистов считают что
делать игры - это круто. Нy, за исключением тех кто действительно
занимается разработкой игр. Написать что-то сложное и красивое, на чём
вы сможете заработать кучу денег, мы, увы, не сможем. Согласитесь,
если бы для создания хороших игр достаточно было бы ваших знаний, то
вряд ли игровая индустрия была бы столь прибыльной — просто из-за
чрезмерного изобилия и разнообразие качественных игр. Ну а написать
что-то простенькое мы вполне уже сможем. Например классическую игру,
в которой компьютер будет пытаться угадать число, загаданное вами.

(видео конспект)

https://drive.google.com/open?id=1X8lkHWLs7HoqujQVrgc9SJUIZXlgLkJt
ramdom ---

(Говорящая голова)

Вот и всё на сегодня. Я сильно рассчитываю на вашу фантазию — не зря
же я рассказал вам как общаться с программой. Просто представьте какие
горизонты теперь открываются — вы, кстати, слышали о текстовых
квестax?  Если нет, обязательно прочитайте о том, что это такое. И
Попробуйте реализовать свою версию. Честное слово, того, что мы успели
изучить, более чем достаточно для этой задачи. Ну и вдруг вы
обнаружите, что вам больше по душе придумывать интересные сюжеты, чем
писать код. Тем не менее, надеюсь это не так и я снова увижу вас на
следующем занятии.