# Материал \#1

## Видео\#1 - Вступление

**Видео - голова**

Всем привет. Сегодня мы рассмотрим один из самых полезных и в то же  
время, зачастую, самых недооцененных инструментов программиста -  
командную строку. Терминал, консоль, CLI - в зависимости от  
используемого погромного обеспечения и жаргона, принятого в вашем  
окружении, название может измениться до неузнаваемости. Но суть этого  
инструмента всегда остается прежней - это один из наиболее  
низкоуровневых интерфейсов вашей операционной системы. И в нашей  
ситуации "низкий уровень" - это вовсе не оскорбление, а всего лишь  
обозначение того факта, что задача данного инструмента быть  
максимально эффективным и понятным самой системе. В силу данного  
обстоятельства, он очень отличается от инструментов "высокого уровня",  
которые должны быть удобны конечному пользователю. Некоторые операции  
будут казаться вам более естественными при использовании  
дополнительного программного обеспечения - файлового менеджера,  
текстового редактора. В конце концов, нам кажется более естественными  
применять курсор мыши для выполнения некоторых операций, потому что он  
будто становится продолжением нашей руки. Использование же различных  
комбинаций клавиш хоть и оказывается временами быстрее, но оставляет  
за собой легкую атмосферу загадочности. Например, щелчок по кнопке  
"закрыть" в заголовке окна - очевидная причина исчезновения этого  
самого окна. Но нажатие комбинации Alt-F4 - просто по какой-то  
загадочной причине делает то же самое. Скорее всего, эта комбинация  
нажимает кнопку закрыть - именно так я бы подумал, если бы хотел  
просто оправдать происходящую магию. На самом деле, клавиши не  
имитируют операции выполняемые курсором. И то, и другое - абсолютно  
равносильные действия. В обоих случаях высокоуровневый графический  
интерфейс посылает сигнал в недра вашего компьютера, благодаря чему  
последний понимает, что ему стоит завершить процесс, на котором в  
данный момент был сфокусирован пользователь. Выходит, вы не обязаны  
даже предпринимать одно из вышеупомянутых действий для закрытия окна -  
нужно лишь понять, как посылать сигналы в систему. И это утверждение  
правдиво для любой операции. Правда, зачастую, использование мыши  
гораздо проще.

---

## **Видео\#2 -Windows Начало работы**

**Видео голова**

Для запуска консоли вам нужно обладать максимально возможно  
целеустремленностью и определенность. Хотя бы, определенностью. Хотя  
бы, постарайтесь определить, какую операционную систему вы  
используете. Если это UNIX система - любой из дистрибутивов Linux,  
FreeBSD, MacOS - консоль у вас будет называться терминалом. Если же  
это Windows - вам нужна командная строка.

В MacOS самым простым способом найти терминал\(если, конечно, он не  
вынесен у вас в докбар\) будет использование Spotlight - поисковой  
системы вашего компьютера. Обычно она доступна в виде иконки поиска в  
правом верхнем углу экрана, либо по комбинации клавиш  
Cmd-Space. Введите в поле 'terminal' - дальнейшие действия должны быть  
очевидными. В виде альтернативы можно открыть папку приложения и в ней  
найти секцию утилит. Именно там спрятан терминал.

Для Windows можно использовать либо классический путь Пуск -&gt; Все  
программы -&gt; Стандартные -&gt; Командная строка, либо же открыть окошко  
"выполнить" с помощью комбинации Win-R и в появившемся окне ввести  
системное название консоли - аббревиатуру CMD, - после чего нажать  
Enter.

В конце-концов, Linux. В большинстве систем вы можете воспользоваться  
комбинацией Ctrl-Alt-T для запуска терминала. Для тех же, кто не любит  
горячие клавиши, всегда есть вариант использования поисковой системы  
вашей графической оболочки. Ради примера, давайте посмотрим, как можно  
запустить терминал в третьем гноме, раз уж он у меня под рукой.

---

> 1.mkv - НЕ могу скачать видео файл?



**Windows: начало работы**

**Скринкаст**

В первую очередь, открываем список приложений.

Затем фокусируемся на поле поиска и вводим название искомой  
программы\(даю подсказку - это по-прежнему, терминал. Хотя, в будущем  
вы можете использовать это бесценное руководство для поиска чего-то  
другого\).

Из полученного списка выбираем наиболее симпатичный нам вариант. Для  
начала подойдет простейший из них.

Готово. Как вы могли заметить, терминал может быть предоставлен в  
нескольких форматах - обычно вы будете использовать тот, который вам  
нравится внешне и функционально. Например, xfce версия, доступная в  
моей системе.

Либо Guake версия. Не имеет значение, какую обертку вы используете -  
это всегда терминал, просто более или менее удобный.

Подобная фауна существует в любой операционной системе. Так что  
экспериментируйте и выбирайте то, что покажется вам наиболее  
удобным. Но сейчас, все же, остановимся на чем-то одном и вернемся к  
нашему уроку.

---

**Видео - голова**

Консоль - это один из возможных интерфейсов вашей системы. С ее  
помощью вы можете сделать почти все то, что можете сделать  
мышью. Разумеется, есть что-то недоступное для консоли, ровно как есть  
что-то, что не сделаешь мышью. Но для большинства простейших задач,  
эти инструменты полностью взаимозаменяемы.

Рассмотрим же использование консоли более подробно. Для начала, зная  
что большинство из вас использует Windows\(я не ясновидящий - это  
просто статистика\), рассмотрим общий процесс работы в командной  
строке.

---

> 2.mkv

**dir **

**скринкаст**

Вы видите черный либо белый экран с неким текстом. У меня белая  
версия. Если приложить немного усилий, то можно даже заметить сходство  
с чем-то до боли знакомым. Верно - первая строка - это путь в вашей  
файловой системе. Так вот - сейчас вы находитесь в некой стандартной  
домашней директории. И путь просто уточняет, в какой именно. Если вы  
откроете проводник в указанной папке, то состояние консоли и окна  
файлового менеджера будут идентичными. Правда, в файловом менеджере мы  
так же видим содержимое текущей папки но это легко  
поправить. Встречайте - команды. Если мы начнем вводить что-то в окне  
консоли, система будет воспринимать это как призыв к действию. Слова,  
которые могут привести к какому-либо результату мы будем называть  
командами. Например - dir - впечатляет, правда?

Если команды, которую мы пытаемся использовать в системе не  
существует, мы получаем ошибку, которая крайне прозрачно намекает на  
факт того, что неправы именно мы. Временами вы будете уверены, что  
команда существует, но система упорно будет отказываться ее  
признавать. В таком случае повторно проверьте введенный текст - велика  
вероятность того, что вы опечатались. Если нет - придется долго и  
мучительно гуглить исток проблемы и в конце-концов выяснится, что вы  
забыли что-то настроить. Милая сторона консоли заключается в том, что  
она всегда права, а вы - нет. Банальную шутку типа "прям как моя  
девушка"\(или парень - никакого шовинизма в этой комнате\) - додумайте  
сами.

Что же это за команда dir? Думаю, тут все очевидно - она показывает  
содержимое текущей директории. Отсюда и название - чтобы не писать  
долгую фразу "покажи что есть в этой папке", умные люди подумали, что  
проще будет использовать просто слово "директория", а потом еще более  
умные люди подумали, что лучше всего использовать только первые три  
буквы этого слова - и так все понятно. В дальнейшем вы увидите, что  
определение слова "понятно" у них сильно отличалось от общепринятого.

Можно заметить, что наряду с содержимым, у нас есть какой-то  
бонус. Первые две колонки содержат дату и время модификации  
данных. Затем мы имеем колонку с типом сущности - пока все отмечено  
как директория, но в будущем будут попадаться, например, варианты без  
лейбла - так обозначаются файлы. Те же самые умные люди в свое время  
решили, что файл - это крайне понятная штука, поэтому его не нужно  
подписывать.

Затем мы видим пустое пространство - в этой колонке будет написан  
размер файлов. По разным причинам, одна из которых - повышение  
производительности, размер директорий отображать не принято.

И, последняя колонка - название каждого файла, папки и, вообще, чего  
угодно. Думаю, сложно не заметить, что список слева и справа  
совпадает. Возможно, если вы используете не английский язык в роли  
системного, консоль будет показывать вам английские названия  
стандартных директорий, в то время как проводник - русские. Тут уже  
играет роль направленность проводника на удобство конечного  
пользователя - хоть на самом деле папки носят английское название,  
такие элементы, как картинки, музыка, документы - переведены на лету  
для вашего удобства. Наблюдаете вы такую особенность или нет, зависит  
от вашей системы. Если наблюдаете - не расстраивайтесь. Просто  
используйте в консоли английские названия элементов. Если не  
наблюдаете - тем более не расстраивайтесь и пишите, как есть.

А как же быть, если вам хочется увидеть содержимое другой папки? Для  
этого придется смириться с мыслью о том, что команды - это еще не все,  
что умеет консоль. Кроме этого существуют еще и аргументы - уточняющие  
слова, либо символы, либо еще что-то, модифицирующее поведение  
команды. Аргументы часто делят на два типа - непосредственно  
аргументы - их мы рассмотрим прямо сейчас, и флаги - о них немного  
позже.

Если вы напишите после dir название одной из папок, расположенных в  
текущем каталоге, то вместо ранее отображаемого содержимого, вы  
увидите контент целевой папки. Например, посмотрим, что у меня в папке  
с проектами. Хмм... куча странных директорий. А если открыть ее в  
проводнике? Как неожиданно - аналогичная ситуация.

Если вы проявите желание узнать, что же находится в одном из моих  
проектов - вас ждет небольшое препятствие. Попытка отобразить каталог  
"питон" заканчивается ошибкой - нет такого файла. В чем же дело? я же  
его вижу! А, точно! я же по прежнему нахожусь в домашней директории. И  
отсюда, как раз таки, проект "питон" не виден. В такой ситуации вам  
просто нужно еще больше погрязнуть в системных дебрях и указать путь,  
каждый компонент которого будет пошагово расписывать продвижение к  
конечной цели. Отдельные компоненты пути должны быть разделены  
слешем - для современных версий windows нет разницы, обратный это слеш  
или обычный. В старых версиях приемлемо только использование обратного  
слеша. В результате, мы прописываем dir затем название каталога  
доступного из текущей позиции, затем слеш, затем дочерний каталог...

Ура! Таким же образом вы можете заглянуть и в папку bin. Просто вводим  
dir, затем название первой папки, теперь попробуем обычные слеши,  
теперь дочерний каталог, теперь обратный слеш и папка bin. Впечатляет,  
не правда ли.

С этим направлением разобрались. А как насчет движения вверх. Можно  
заметить, что сейчас я в директории home/sergey. А что еще есть в этой  
папке, кроме каталога с моим именем? Тут все немного сложнее с точки  
зрения мнемоники, но запись выйдет короче.

Для начала, присмотритесь - вас не смущают эти два странных пункта,  
которые появляются в каждом результате - точка и две точки? Меня  
смущают. Точнее, смущали. А потом оказалось, что нет в них ничего  
странного, пусть их и не видно в окне проводника. Дело в том, что  
точка - это ссылка на текущую папку. То-есть, просто dir и dir с  
точкой покажут один и тот же результат. Более того, в каждой папке  
есть точка, которая указывает на саму эту папку. Например,  
Projects/. - это просто Projects.Даже более того, так как точка - это  
то самое место, где вы находитесь\(назовем его "здесь"\), в ней тоже  
есть точка, которая по-прежнему "здесь". И так до бесконечности. Это  
означает, что путь вроде точка точка точка является вполне  
корректным\(хоть и бесполезным, потому что никуда вас не сдвинет\).

Подобным образом работают две точки, хоть их кпд значительно выше. Они  
указывают на родительский каталок. Соответственно, чтобы увидеть  
содержимое home, при условии, что я в home\sergey, мне нужно проверить  
dir две точки. Кстати, о бесполезных действиях - dir две точки -  
sergey - покажут то же самое, что и dir точка, либо просто dir -  
текущую папку. И при желании можно опять построить бесконечную  
цепочку.

Поднявшись на два уровня, мы увидим содержимое корня файловой  
системы. Подняться еще выше, увы не получится. В корне файловой  
системы две точки, ровно как и одна, указывают на текущее положение. С  
другой стороны, вы не получите ошибку, если введете на одну пару точек  
больше.

Такие пути называют относительными - начальной точкой отсчета всегда  
является текущее местоположение и все пути рассчитываются относительно  
него. Отсюда и название. Временами это будет казаться не самой лучшей  
стратегией. Например, вы находитесь глубоко-глубоко в дереве файловой  
системы и вам нужна папка в ее корне. и вам крайне лень подсчитывать и  
вводить кучу точек. Только для вас! Существует второй тип путей -  
абсолютные. Потому что в абсолютно любой позиции, где бы вы не  
находились, они рассчитываются относительно одной и той же точки -  
корня файловой системы. Обладать какими то выдающимися талантами для  
их использования вовсе не нужно. Достаточно начать пусть со  
слеша. То-есть, абсолютно в любой папке я могу ввести dir слеш и  
увидеть содержимое корневой директории. Абсолютно везде dir слеш home  
покажет мне содержимое папки home. Просто, не правда ли?

---

## Видео\#3 - **Unix**

**Видео -  голова**

ОК, насладились командной строкой и посмотрим, что же там в  
терминале. Если у вас windows система - можете воспринимать дальнейшую  
информацию, как факультативную, но я все же советую найти какой-либо  
онлайн эмулятор терминала и поэкспериментировать с ним. В конце  
концов, вы даже можете установить подобную вещь себе на компьютер -  
хорошим экземпляром можете считать GitBash - он вам обязательно  
пригодится в будущем. Установить его можно вместе с самим приложением  
git, которое, в свою очередь вы можете безопасно скачать с сайта  
git-scm.com.

Начнем. Первое, что стоит заметить - в unix системах отсутствует  
понятие разделов жесткого диска C:, D:, E:, как в  
windows. Единственным корнем файловой системы тут является папка  
слеш. Само разделение файловой системы на разделы присутствует, но  
реализовано оно крайне своеобразно и рассмотрение этой системы мы  
оставим энтузиастам.

Идея использования команд, аргументов и флагов - прежняя, но список  
команд достаточно сильно отличается. Есть совпадающие команды, есть и  
отличные. Одно можно сказать точно - из коробки, без дополнительных  
настроек, возможностей тут будет побольше

---

> 3.mkv



**Unix**

**скринкаст**

Команда dir тут показывает немного меньше информации - просто  
перечисление доступных элементов. Более распространенной командной  
считается ls. Результат ее использования точно такой же, как и у  
dir\(не обращайте внимание на цвет - это мои настройки\), но она короче  
на один символ. На самом деле dir в unix - просто псевдоним для ls.

Если же вы хотите получить более схожий с windows результат - вам  
нужно использовать флаги. Наконец-то мы до них добрались. Обычные  
аргументы влияют на цель команды. В виде примера, путь в случае dir  
определял целевую директорию, чье содержимое мы желали увидеть. Флаги  
же, обычно, хоть и бывает достаточно много исключений, меняют то КАК  
операцию будет выполнена

в зависимости от команды, способ и место написания флагов может  
отличаться. Чаще всего флаги пишут либо до, либо после  
аргументов. Кроме того, перед самими флагами ставят один или два  
минуса, чтобы отличить их от аргументов. Причем количество минусов  
определяется не наугад, а по целому своду правил.

В случае ls, популярным флагом можно считать -l - он требует показать  
результат не в виде перечисления, а в виде списка. Чаще его ставят  
перед указанием целевой папки, если она присутствует, но, в принципе,  
ничего не сломается, если вы укажете этот флаг в самом конце комманды.  
То есть, следующие два примера идентичным...

В остальном, все сказанное про относительные и абсолютные пути  
применимо и тут.

Как же узнать список всех доступных флагов и вообще, как использовать  
команду? Для большинства Unix команд включена поддержка флага два  
минуса help. Как видите - справка достаточно внушительная. В windows  
большинство новых команд работают по такому же принципу, в то время  
как старые предпочитают необычный флаг слеш знак вопроса. Вот  
пример...

В настоящей windows объем справки будет побольше и, в зависимости от  
настроек вашего компьютера, возможно даже на русском. Хотя я бы  
посоветовал всем, кто еще не овладел английским на разговорном уровне,  
активно этим заняться - в нашем деле знание иностранных языков сильно  
упрощает поиск нужной информации и, нередко, общение с заказчиком.

---

> 4.mkv

**Скринкаст**

Следующая команда, с которой мы столкнемся - cd - сокращение от change  
directory и, для тех кому мое произношение режет слух, она изменяет  
ваше местоположение в консоли. То есть этой командной вы выполняете  
то, что обычно делаете дважды кликнув по папке. Работа с путями тут  
абсолютно идентична вышеизложенному, так что не буду повторятся.

При применении этой команды, как несложно заметить, меняется строка с  
текущим местоположением. Забыл сразу уточнить - в unix системах вы  
будете часто видеть тильду - вот эта самая волнистая линия. Так тут  
принято ссылаться на домашний каталог пользователя. То-есть, сейчас я  
вовсе не в папке тильда-Projects, а в home/sergey/projects.

Хмм.. А как узнать, где вы находитесь? Да, я вижу что у меня и так это  
написано на экране. Но вдруг вы не знаете, какая папка считается  
домашней для этого пользователя и вам срочно нужно расшифровать эту  
сноску? В такой ситуации windows лидирует в простоте - вам просто  
нужно ввести команду cd  и вы увидите на следующей строке вашу текущую  
позицию. В случае unix ... вот неудача, правда? cd без аргументов  
перебросила нас в нашу домашнюю директорию. Ох уж эти различия. Для  
данной операции в unix системах используется совершенно другая  
команда - pwd. В windows такой команды нет, да она и не нужно - так как  
решением всех проблем сделали cd.

Если вдруг вы тоже случайно ввели cd без аргументов по ошибке в unix  
системе и вам сейчас настолько не хочется вручную возвращаться назад,  
что проще просто закрыть браузер и включить любимый сериал, расскажу  
маленький секрет. Опять таки, только для unix. Чтобы вернуться в  
предыдущую директорию, какой бы она не была, можно использовать  
аргумент минус команды cd. Пробуем... фух, ладно раз можно так, то  
дадим этому курсу еще один шанс.

Кстати, если вы не догадались, dir будет всегда выводить содержимое  
того каталога, в котором я нахожусь именно сейчас. Так что вместо dir  
путь к директории, вы можете сначала в нее перейти, а потом вызвать  
dir без аргументов.

Количестве полезных советов начинает превышать  
допустимую норму - нужно держать себя в руках - я все это раскрывал  
для себя часами мучительных поисков, будет скучно если вы сразу  
узнаете все секреты, правда?

---

**Видео - голова**

Команд, подобных рассмотреным ранее, достаточно много. В windows для  
вывода всех стандартных действий, вы можете воспользоваться командой  
help. В unix системах командные запасы практически безграничны и мне  
неизвестен способ вывести абсолютно все, что может ваша система. Тут  
гораздо проще искать действие под ваши нужны - практически всегда вы  
сумеете найти способ сделать то, что требуется, с помощью  
терминала. Кроме того, большинство стандартных программ также можно  
запустить из терминала. Например, проводник доступен под именем  
explorer в windows. если вы просто введете его название, вероятнее  
всего в нем откроется домашняя директория текущего  
пользователя. Указывая аргумент, вы добиваетесь контролируемого  
открытия определенной директории. В linux подобного можно добиться с  
использованием программы nautilus, thunar или же другого используемого  
вами файлового менеджера. В конце концов, на mac os для этой цели  
используется простая лаконичная open.

Другой пример - текстовые редакторы. Если у вас в системе установлен  
блокнот - он доступен как notepad. Без аргументов он открывается с  
пустым несохраненным документом. Если вы указываете несуществующий  
путь в процессе запуска - блокнот предложит вам создать этот файл. А  
если укажете путь к существующему файлу - этот файл будет открыт для  
редактирования. Редакторы, браузеры, плееры - абсолютно все может быть  
открыто таким образом. Нужно только знать название программы. Или  
способ ее найти.

На системном уровне организация всех этих процессов крайне проста. В  
вашей системе существует специальная конфигурационная директива -  
путь. Это просто перечисление всех каталогов, в которых могут лежать  
полезные программы. В момент ввода команды и нажания enter, терминал  
пробегает по всем директориям пути и ищет исполняемый файл с  
названием, идентичным названию команды. Первый найденый претендент и  
выполняет всю дальнейшую работу. Так что для добавления возможности  
запуска абсолютно любой программы с помощью консоли вам нужно только  
узнать расположение этой программы и добавить нужный адрес в системные  
пути. Способы будут сильно отличатся в  зависимости от системы, но в  
интернете полно руководств - так что почему бы не попробовать в  
ближайшую неделю по максимуму использовать консоль для всех возможных  
задач - от создания\удаления файлов, до открытия любимых сайтов в  
браузере - это будет отличной практикой. Я еще не встречал людей,  
которые разобрались в том, как работает консоль и жалеющих об этом. Не  
стоит думать, что вы станете ужасным гиком, как только правда вам  
раскроется - скорее всего вы так и не будете использовать командную  
строку, кроме тех случаев, когда без нее не обойтись. Но профит будет  
в том, что вы суммеете это сделать, когда появится необходимость.

---

## Видео\#4 - Интерпретатор python

**Видео - голова**

А теперь поговорим о самом Python. Возможно вы уже знаете, что языки  
программирования можно разделить на две категории - компилируемые и  
интерпретируемые.

Компилируемые языки предполагают, что вы сначала  
пишете код, который затем обрабатываете программой компилятором. Она  
преобразует текст вашей программы в исполняемый файл или библиотеку  
кода, которая написана понятным компьютеру языком. И кране непонятным  
для нормального человека. Разобрать, что делает программа, не выполнив  
обратного преобразования - крайне трудоемкая задача. А зачастую полностью  
восстановить исходный код обратным преобразованием просто невозможно,  
потому что компиляторы вносят определенное количество правок в ваш код  
и стараются максимальное его оптимизировать. Как результат, чтобы  
исправить программу, вам нужен ее исходный код, который бывает крайне  
сложно найти. Кроме того, если программа большая, как, например,  
photoshop или современные игры, внесение небольшого исправления в код  
и повторная компиляция может оказаться весьма длительным  
процессом. Так что, компилируемые языки - это море страданий, унижений  
и боли. Хотя, я так говорю только потому что python относится к  
противоположной фракции.

Если говорить о преимуществах - вы можете скомпилировать программу под  
любую целевую систему и для запуска в конце концов вам будет нужна  
только сам исполняемый файл. Знания о том как, кем, когда она написана не  
внесут абсолютно никаких изменений в ее работу .

Вторая группа - это интерпретируемые, или же транслируемые языки. Язык  
можно сломать, честное слово. Их особенность в том, что программы  
созданные с помощью таких языков интерпретируются на лету, строка за  
строкой. Благодаря этому, если вам очень нужно поправить программу -  
вы просто открываете ее в текстовом редакторе, правите строчку кода и  
вот, она уже не та, что прежде. Удобно, не так ли? К сожалению, в виде  
платы за подобное удобство, мы теряем скорость - компьютер вынужден  
каждый раз переводить программу с человеческого языка на машинный. В  
свете современного развития технологий это не столь уж большая  
потеря - разве что вам важны нано и микро секунды. С точки зрения  
человека, до тех пор пока вы не начнете обрабатывать огромные объемы  
информации, никакой разницы в скорости нет.

Тем не менее остается еще одна проблема. Чтобы компьютер мог перевести  
вашу программу, ему нужен словарь - транслятор. Или же  
интерпретатор. Программа, которая преобразует ваш код в машинный. Как  
результат - кроме вашей программы на компьютере конечного пользователя  
также должен быть установлен бонусный софт в виде интерпретатора  
вашего языка. В случае написания программ для внутренних систем, или  
создания сайтов - проблема вовсе не релевантна. Так как мы запускаем  
код на своих компьютерах, мы можем их настроить должным образом. Если  
же мы хотим создать приложение для внешнего пользователя, игру,  
например, - установка интерпретатора на его компьютере может немного  
смутить.

Опять таки, это не принципиальный недостаток. Если вы увлекаетесь  
играми, то вам наверняка не раз приходилось устанавливать какие-то  
драйвера, библиотеки, патчи. То есть, и компилируемые языки временами  
требуют что-либо дополнительно - просто это происходит значительно  
реже.

Вывод из всего этого - нет идеального универсального решения. В  
зависимости от требований, возможностей, особенностей проекта и также  
от тысячи других причин чаша весов может склониться в любую  
сторону. Мы, а точнее - Вы, выбрали python и вам с этим жить. Хотя, не  
думаю, что я хоть раз пожалел о том, что в свое время приложил усилия  
и потратил время на его изучение.

Любителям статистики советую заглянуть на сайт tiobe.com - эти  
ребята специализируются на всякого рода рейтингах. У них в заголовке  
сайта есть неприметная ссылочка TIOBE index, которая содержит рейтинг  
популярности языков программирования, основанный на десятке разных  
факторов.

Отличная идея, кстати, давайте прям сейчас туда и глянем.

---

> 5.mkv

**Скринкаст**

Вот сам сайт. А вот и та ссылка, о которой я говорил...  
Что ж, состояние на январь 2018 года меня крайне радует. При желании  
можно так же посмотреть тенденцию изменения популярности и,  
разумеется, сравнить с другими языками - любуйтесь и не  
заморачивайтесь сильно рейтингами - главное, чтобы этот язык нравился  
именно вам.

---

## Видео\#5 -Установка Python

**Видео - голова**

Если вы внимательно читали требования к курсу, то сам интерпретатор  
python у вас уже установлен. Но, контроль никогда не бывает лишним,  
поэтому давайте быстро пробежимся по основным этапам установки в  
случае windows. В unix системах python почти включен в базовый набор  
пакетов, так что переживать о его установке не нужно.

---

> 6.mkv

**Скринкаст**

Скачать python можно с сайта python.org. тут же вы можете найти ссылку  
на официальную документации и много других инитересностей.

Секция загрузок позволяет выбрать как исходный код python, так и  
готовые сборки под отдельные операционные системы. Кроме этого, вы  
можете выбрать версию интерпретатора. Мы остановимся на максимально  
новых возможностях...

Установка достаточно проста - нужно непрерывно со всем  
соглашаться. Внимания требует только один момент. Перед установкой вы  
должны согласиться с добавлением python в системные пути - делается  
это простым добавлением галочки на одном из стартовых окон  
установки. Благодаря этой опции, сразу после установки, без  
дополнительных настроек, в вашей консоли появится новая команда,  
которую мы будем активно использовать.

После завершения установки нам нужно проверить работоспособность  
инструментов. Если у вас уже была запущена консоль - перезапустите ее,  
для того, чтобы она заметила появление новой команды.

После чего введите команду python  с флагом -V, причем буква в  
обязательно должна быть записана в верхнем регистре. Идеальный  
результат заключается в получении подобного вывода. Если вы  
обнаружили, что у вас вторая версия python вместо третьей и вы  
используете unix систему - не паникуйте. Вероятно стандартой системной  
версией тут выбрана ветка два, а третья версия просто установлена про  
запас. Так, например реализовано в linux ubuntu. Попробуйте  
команду python3 -V. Если сработало - впоследствии всегда используйте  
именно ее каждый раз, когда я использую python. Если нет, вам придется  
вручную установить третью версию в вашу систему.

Кстати, если у вас по умолчанию выбран третий python - есть  
вероятность того, что второй доступен как python2. Попробуйте  
соответствующую команду для проверки версии. В общем, он нам не  
понадобится, так что результат ничего не изменит, но знания никогда не  
оказываются лишними.

---

**Видео - голова**

Сама по себе команда python запускает интерпретатор, а различные флаги  
управляют режимом работы. Например, V - ограничиться показом  
версии. v в нижнем реегистре - запустить интерпретатор с  
дополнительным логированием всех внутренних событий. c - выполнить  
код, переданный аргументом и многое другоe. В большинстве случаев вам  
либо вообще не придется использовать никакие флаги, либо придется  
запомнить два-три наиболее полезных и ограничиваться только ими.

---

> 7.mkv

**Скринкаст**

То что вы сейчас видите на экране - это и есть интерпретатор python. В  
данный момент он запущен в интерактивном режиме, то есть моментально  
реагирует на введенный нами код. Через несколько уроков мы начнем  
писать код в реальных файлах и тогда интерпретатор будет  
использоваться, как обработчик этих файлов.

Вернемся к настоящему. Как видите, интерпретатор работает внутри  
консоли. С одной стороны - да, это по прежнему терминал. Но прежней  
осталась только оболочка. Все команды, которые мы будем вводить,  
теперь обрабатываются не самой операционной системой, а только  
интерпретатором. Если нам понадобиться что-то сделать на системном  
уровне - мы можем запустить параллельно еще один сеанс консоли...

Таким образом - одно окно используется для взаимодействия с системой,  
второе - для работы в интерпретаторе. Каких-либо реальных ограничений  
на количество сеансов консоли вроде бы не существует, но вряд ли вам  
когда нибудь понадобится количество, превышающее пять-шесть штук.

Вернемся к программированию. что же такого особенного в этом варианте  
терминала? Самое главное отличие - все, что мы вводит тут, должно быть  
валидным или, другими словами, корректным кодом на python. Его  
синтаксис значительно богаче того, что мы видели раньше в командной  
строке. Тут дело не ограничивается одними только командами и  
аргументами, хотя и существует похожее понятие.

Начинать стоит с простейшего. Чтобы почувствовать себя  
программистами - начинайте вводить в интерпретатор числа и нажимать  
enter...

Круто, не правда ли? Ладно-ладно, не переживайте. Это только начало и  
продвижение к более крутому коду требует хорошего понимания основ. Тут  
мы уже наблюдаем две особенности. во-перывых, интерпретатор понимает  
числа. Ну хотя бы пытается. Во-вторых, при попытках сделать что-то  
слегка по-своему - все ломается. Не ломается? Вы просто еще не  
пытались его сломать. Попробуйте ввести число не с начала  
строки. То-есть поставьте пару пробелов кроме того, который отделяет  
ваш ввод от этих трех угловых стрелок.

Совсем другое дело. Небольшой интеллектуальный груз из английских слов  
или же гугл переводчик позволяет нам определить причину ошибки -  
неожиданный отступ. Первый способ что-то сломать. Идем далее.

пытаемся написать число, десять тысяч, к примеру, в котором разряды  
будут разделены пробелом...

Вторая ошибка. Некорректный синтаксис.

А теперь - один миллион. Но разделяем разряды не пробелом, а точкой...

Снова некорректный синтаксис.

Ладно, последняя попытка - то же самое, но разряды разделены  
запятой...

а вот это совсем неожиданно. Теперь никакой ошибки нет, но на миллион  
это совсем непохоже.

---

**Видео**

Разберем произошедшее. Попытка написать что-то неправильно приводит  
либо к ошибке, либо к странному результату. Как же понять, что писать  
можно, а что - нет? В действительности, тут как и в любом языке, не  
только языке программирования, но и человеческом, есть свой свод  
правил. Их гораздо меньше, чем, например, в русском и они гораздо  
строже, чем в английском. Так что выучить их вполне можно, но вам  
необходимо добиться мышления на python, чтобы не пытаться перевести  
свои мысли в программу, а сразу мыслить фрагментами кода. Это сильно  
упрощает жизнь.

Некорректный отступ. Это одна из интересных и любимых многими  
особенностей этого языка. Вам будет крайне сложно писать непонятный и  
запутанный код, потому что сами правила синтаксиса построены таким  
образом, что только красивый код будет правильным. Я немного  
преувеличиваю, но это общая идея, в которую лучше верить. Одним из  
доказательств этого утверждения можно считать факт того, что любую  
самостоятельную команду нужно писать с новой строки. А ступы нужно  
добавлять только в тех командах, которые как-либо зависят от  
предыдущих. Например, проверить, залогинен ли пользователь и создать  
запись в блоге - самостоятельные действия, каждое нужно начинать с  
новой строки. А вот если мы захотим сказать, что сначала нужно  
проверить, залогинен ли пользователь, а потом создать новую запись в  
блоге, но только если предыдущая проверка дала положительный  
результат - тут уже нужно писать вторую строку с отступом. Благодаря  
чему даже форма кода может вам что-то рассказать о взаимодействии  
отдельных функциональных единиц.

Следующая проблема - синтаксическая ошибка. Что бы вы не писали,  
существуют правила оформления отдельных смысловых единиц - чисел,  
текста, утверждений, коллекций данных. Прям как "жи\ши пиши с и". И  
если вы делаете ошибку - программа просто останавливается. Сразу такая  
строгость может показаться чрезмерной, но вы быстро научитесь ее  
ценить. Если  в программе не будет даже мельчайших опечаток - тогда  
можно быть уверенным на 100 процентов, что не появится двусмысленных  
ситуаций и ваш код будет делать только то, что в нем написано, без  
додумываний и предположений. Так что тут проявляется еще одна  
идеология - код должен быть максимально прозрачным и очевидным, всегда  
старайтесь избегать неявных действий и побочных эффектов.

И в конце концов, странные числа 1, 0 и 0 в скобках. Об этом в деталях  
мы поговорим позже, пока просто ограничимся фактом того, что в питоне  
таким образом, с помощью запятой, принято записывать коллекции данных,  
например, последовательность чисел. Если вы запишите просто 100 - это  
будет выглядеть как одно число. Потому в python можно записывать  
несколько чисел через запятую, как бы подчеркивая, что это  
самостоятельны числа, объединенные общей характеристикой. Например -  
последовательность цифр в пароле. Ну и для самых придирчивых - один,  
два, три и любое другое количество идущих подряд нулей, воспринимаются  
в python как обычный ноль. Но только если в результирующей записи  
отсутствуют любые другие числа. Подробнее на форматах записи чисел мы  
остановимся на следующем уроке.

Так что писать на python станет крайне просто, как только вы усвоите  
основные правила. Воспринимайте это как изучение иностранного языка -  
вы увидите, что аналогий в действительности крайне много, хотя сам  
процесс гораздо проще.

---

## ** видео\#6 - Python переременные**

**Видео - голова**

И последняя секция на сегодня - переменные. Забегая наперед, скажу что  
со временем вам надоест писать одни и теже выражения в коде. Например,  
написали вы некое число, один миллиард. Затем захотели на него  
посмотреть и вывели его на экран. Потом еще раз.

Потом решили умножить его на 100. А потом разделить на 20. И вычесть  
пару миллионов. Если все эти операции выполнять последовательно - вам  
придется каждый раз вводить предыдущий результат, для перехода на  
следующий уровень. Как бы сделать что-то такое, что уменьшит  
колличество вводимых символов?

---

> 8.mkv

**Скринкаст**

Сначала посмотрим на проблему вживую. Вот мы записали миллиард...

Далее, я прибавляю к нему два...

Теперь, делю полученный результат на 105...

И умножаю на 3...

Как видите - постоянно приходится вводить числа, хоть я их и не  
озвучивал устно.  А уж если я пойму, что начинать нужно было не с  
миллиарда а с девятиста миллионов - придется все переписывать с нуля.

Проблему можно сделать менее критичной - если мы нажмем стрелку вверх  
в интерпретаторе - в него будет подставлена последняя выполненная  
комманда. Дважды - предпоследняя. И так далее. Выходит, мы можем  
просто щелкать нужное количество раз вверх, после чего менять одно из  
чисел и пересчитывать результат. Но, это не сильно помогает. Нужно  
нечто более эффективное.

Для решения данной проблемы, во многих языках программирования  
существует концепция переменных. Представьте множество ящиков в  
комоде. У каждого ящика есть имя. Но давайте не будем называть ящик  
Сергеем, пусть это будут имена а, б, ц, д. Сейчас мы видим ошибку -  
имя не определено. Но есть и хорошая сторона - python понимает, что мы  
пытаемся использовать чъе-либо имя. Значит нужно всего лишь определить  
это самое имя.

Для этого используется конструкция присваивания. Мы пишем название  
нашего ящика... Давайте я все же буду использовать слово  
"переменная", - затем добавляем символ "равно", как бы сообщая, что  
"ящик - это...". И затем говорим, что же такое ящик. Или, для большей  
адекватности - что же в нашем ящике хранится.

И вот у нас появился ящик с миллиардом чего-то, что не может не  
радовать. Теперь, каждый раз, когда мы вводим в интерпретатор имя этой  
переменной, он будет заглядывать в наш комод и вытаскивать нужное  
значение. То-есть, интерпретатор не видит переменных, он видит то, что  
в них хранится. Так что теперь я могу сложить миллиард с двумя, или же  
делить его на 80. Да и все дальнейшие операции тоже  
допустимы. Представляйте, что вместо переменной у нас реальное  
число. Более того, если я захочу, то все остальные результаты тоже  
можно сохранять в переменную.

Например сумма миллиарда и двойки. Если я попытаюсь записать ее в  
переменную, python понимает, что мне нужно сохранить не название  
операции, не плюс, а именно результат, вне зависимости от того, как он  
получен. Сначала мы складываем два числа, а потом сумму кладем в  
ящик. Но если интерпретатор заменяет переменную на ее значение,  
выходит я могу складывать не миллиард с двойкой, а первую переменную с  
двойкой - ведь так гораздо короче. Теперь, с моей стороны, все  
выглядит гораздо опрятнее. А интерпретатор выполняет три действия:

* заменяет переменную на ее значение
* суммирует числа
* сохраняет результат в новую переменную.

И вот мы можем сохранить каждый шаг нашей вычислительной  
цепочки... Важно заметить, что сохраняются именно результаты и нет  
никакой возможности узнать о способе их получения. Если я со временем  
захочу выбросить значение из первого ящика и положить туда что-то  
новое - я просто скажу, что переменная равна чему-то новому. Python  
сам обнаружит старое значение, поймет, что этот город слишком тесен  
для них двоих и незаметно выбросит старое - нам не нужно об этом  
думать. Но, если первая переменная теперь равна десяти, не изменится  
ли значение второй? Никогда. Снова повторюсь - интерпретатор не  
запоминает КАК были получены значения. Поэтому во второй переменной у  
нас не сумма текущего значения с двойкой, а именно сумма миллиарда с двойкой.

---

**Видео - голова**

И на таких огромных числах мы сегодня остановимся. Не знаю как вы себя  
чувствуете, но я кажется узнал что-то новое. Удивить таким можно разве  
что пожилую бабульку, но теперь то хоть кто-то может назвать вас  
программистом. С каждым уроком мы будет узнавать все больше о правилах  
синтаксиса и растространенных идеях. Не нужно недооценивать отдельные  
моменты - абсолютно каждую пройденную тему вы должны разобрать на  
таком уровне, чтобы перестать понимать, как вообще раньше вы жили не  
зная этого! До тех пор, пока код программы заставляет вас задумчиво  
чесать подбородок, пока вы не начнете читать программы в  
повествовательной манере - вам есть чему учиться. А уж дойдя до этой  
стадии - начинайте активнее писать программы - документальные,  
детективные, юмористические, хорроры - почувствуйте себя творцом!

Что ж, я уже слышу, как на кухне закипел чайник - мне пора. А вы  
остывайте и не опаздывайте на следующую лекцию. До скорых встреч.

